# This file is generated by quick.py. Do not edit.
# Run q quick rebuild to regenerate.

if [[ -z "${_REDSHELL_GEN_QUICK}" || -n "${_REDSHELL_RELOAD}" ]]; then
_REDSHELL_GEN_QUICK=1
function __q() {
  if [ "$#" -eq 0 ]; then
    __q_help
    return 0
  fi
  case "$1" in
  help|-h|--help|?)
    shift
    __q_help "$@"
    ;;
  dump)
    shift
    __q_dump "$@"
    ;;
  ascii_art)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "ascii_art" "$@"
      ;;
    print_speech_bubble)
      shift
      print_speech_bubble "$@"
      ;;
    erase_lines)
      shift
      erase_lines "$@"
      ;;
    cursor_position)
      shift
      cursor_position "$@"
      ;;
    cursor_row)
      shift
      cursor_row "$@"
      ;;
    print_bmo)
      shift
      print_bmo "$@"
      ;;
    print_pedro)
      shift
      print_pedro "$@"
      ;;
    scroll_output_pedro)
      shift
      scroll_output_pedro "$@"
      ;;
    select_visual)
      shift
      select_visual "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module ascii_art has no function $1"
      fi
      __q_help ascii_art
      return 1
      ;;
    esac
    ;;
  bash)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "bash" "$@"
      ;;
    get_bash_functions)
      shift
      get_bash_functions "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module bash has no function $1"
      fi
      __q_help bash
      return 1
      ;;
    esac
    ;;
  browser)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "browser" "$@"
      ;;
    gdocs_id)
      shift
      gdocs_id "$@"
      ;;
    sheets_dl_link)
      shift
      sheets_dl_link "$@"
      ;;
    chrome_path)
      shift
      chrome_path "$@"
      ;;
    downloads_path)
      shift
      downloads_path "$@"
      ;;
    browser_dl|dl)
      shift
      browser_dl "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module browser has no function $1"
      fi
      __q_help browser
      return 1
      ;;
    esac
    ;;
  crypt)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "crypt" "$@"
      ;;
    encrypt_symmetric)
      shift
      encrypt_symmetric "$@"
      ;;
    decrypt_symmetric)
      shift
      decrypt_symmetric "$@"
      ;;
    gen_github_keypair)
      shift
      gen_github_keypair "$@"
      ;;
    package)
      shift
      package "$@"
      ;;
    payloadify)
      shift
      payloadify "$@"
      ;;
    downloadify)
      shift
      downloadify "$@"
      ;;
    crypt_hash|hash)
      shift
      crypt_hash "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module crypt has no function $1"
      fi
      __q_help crypt
      return 1
      ;;
    esac
    ;;
  fedora)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "fedora" "$@"
      ;;
    fedora_setup|setup)
      shift
      fedora_setup "$@"
      ;;
    dnf_install_or_skip)
      shift
      dnf_install_or_skip "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module fedora has no function $1"
      fi
      __q_help fedora
      return 1
      ;;
    esac
    ;;
  find)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "find" "$@"
      ;;
    f)
      shift
      f "$@"
      ;;
    fcc)
      shift
      fcc "$@"
      ;;
    fgo)
      shift
      fgo "$@"
      ;;
    fjava)
      shift
      fjava "$@"
      ;;
    faidl)
      shift
      faidl "$@"
      ;;
    fd)
      shift
      fd "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module find has no function $1"
      fi
      __q_help find
      return 1
      ;;
    esac
    ;;
  git)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "git" "$@"
      ;;
    mkproject)
      shift
      mkproject "$@"
      ;;
    git-ssh-init)
      shift
      git-ssh-init "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module git has no function $1"
      fi
      __q_help git
      return 1
      ;;
    esac
    ;;
  go)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "go" "$@"
      ;;
    go_pkg_do|pkg_do)
      shift
      go_pkg_do "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module go has no function $1"
      fi
      __q_help go
      return 1
      ;;
    esac
    ;;
  hg)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "hg" "$@"
      ;;
    hg_root|root)
      shift
      hg_root "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module hg has no function $1"
      fi
      __q_help hg
      return 1
      ;;
    esac
    ;;
  init)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "init" "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module init has no function $1"
      fi
      __q_help init
      return 1
      ;;
    esac
    ;;
  install)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "install" "$@"
      ;;
    reinstall_file)
      shift
      reinstall_file "$@"
      ;;
    install_file|file)
      shift
      install_file "$@"
      ;;
    uninstall_file)
      shift
      uninstall_file "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module install has no function $1"
      fi
      __q_help install
      return 1
      ;;
    esac
    ;;
  keys)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "keys" "$@"
      ;;
    keys_git|git)
      shift
      keys_git "$@"
      ;;
    keys_path|path)
      shift
      keys_path "$@"
      ;;
    keys_var|var)
      shift
      keys_var "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module keys has no function $1"
      fi
      __q_help keys
      return 1
      ;;
    esac
    ;;
  mac)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "mac" "$@"
      ;;
    mac_setup|setup)
      shift
      mac_setup "$@"
      ;;
    brew)
      shift
      brew "$@"
      ;;
    mac_get_user_shell|get_user_shell)
      shift
      mac_get_user_shell "$@"
      ;;
    mac_brew_bash_path|brew_bash_path)
      shift
      mac_brew_bash_path "$@"
      ;;
    mac_switch_to_bash|switch_to_bash)
      shift
      mac_switch_to_bash "$@"
      ;;
    icloud)
      shift
      icloud "$@"
      ;;
    icloud_evict)
      shift
      icloud_evict "$@"
      ;;
    brew_install_or_skip)
      shift
      brew_install_or_skip "$@"
      ;;
    mac_install_miniconda|install_miniconda)
      shift
      mac_install_miniconda "$@"
      ;;
    mac_install_devtools|install_devtools)
      shift
      mac_install_devtools "$@"
      ;;
    mac_kill_defender|kill_defender)
      shift
      mac_kill_defender "$@"
      ;;
    mac_suppress_defender|suppress_defender)
      shift
      mac_suppress_defender "$@"
      ;;
    mac_kill_crashplan|kill_crashplan)
      shift
      mac_kill_crashplan "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module mac has no function $1"
      fi
      __q_help mac
      return 1
      ;;
    esac
    ;;
  media)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "media" "$@"
      ;;
    yt-dl)
      shift
      yt-dl "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module media has no function $1"
      fi
      __q_help media
      return 1
      ;;
    esac
    ;;
  monitor)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "monitor" "$@"
      ;;
    stream_load_stats)
      shift
      stream_load_stats "$@"
      ;;
    load_hist)
      shift
      load_hist "$@"
      ;;
    latest_load_stats)
      shift
      latest_load_stats "$@"
      ;;
    write_load_stats)
      shift
      write_load_stats "$@"
      ;;
    stream_top_stats)
      shift
      stream_top_stats "$@"
      ;;
    stream_net_stats)
      shift
      stream_net_stats "$@"
      ;;
    proc_stats)
      shift
      proc_stats "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module monitor has no function $1"
      fi
      __q_help monitor
      return 1
      ;;
    esac
    ;;
  mtg)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "mtg" "$@"
      ;;
    mtg_oracle_json|oracle_json)
      shift
      mtg_oracle_json "$@"
      ;;
    mtg_rules|rules)
      shift
      mtg_rules "$@"
      ;;
    mtg_card_json|card_json)
      shift
      mtg_card_json "$@"
      ;;
    mtg_card|card)
      shift
      mtg_card "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module mtg has no function $1"
      fi
      __q_help mtg
      return 1
      ;;
    esac
    ;;
  multiple_choice)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "multiple_choice" "$@"
      ;;
    multiple_choice)
      shift
      multiple_choice "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module multiple_choice has no function $1"
      fi
      __q_help multiple_choice
      return 1
      ;;
    esac
    ;;
  net)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "net" "$@"
      ;;
    dataurl)
      shift
      dataurl "$@"
      ;;
    rtt)
      shift
      rtt "$@"
      ;;
    ip4)
      shift
      ip4 "$@"
      ;;
    ip4gw)
      shift
      ip4gw "$@"
      ;;
    serve)
      shift
      serve "$@"
      ;;
    dump_url)
      shift
      dump_url "$@"
      ;;
    wiki)
      shift
      wiki "$@"
      ;;
    wifi_device)
      shift
      wifi_device "$@"
      ;;
    wifi_name)
      shift
      wifi_name "$@"
      ;;
    net_ssh_fingerprint|ssh_fingerprint)
      shift
      net_ssh_fingerprint "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module net has no function $1"
      fi
      __q_help net
      return 1
      ;;
    esac
    ;;
  notes)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "notes" "$@"
      ;;
    notes_note|note)
      shift
      notes_note "$@"
      ;;
    notes_list|list)
      shift
      notes_list "$@"
      ;;
    notes_sync|sync)
      shift
      notes_sync "$@"
      ;;
    notes_todo|todo)
      shift
      notes_todo "$@"
      ;;
    notes_undo|undo)
      shift
      notes_undo "$@"
      ;;
    notes_perl|perl)
      shift
      notes_perl "$@"
      ;;
    notes_api_list_notes|api_list_notes)
      shift
      notes_api_list_notes "$@"
      ;;
    notes_backup|backup)
      shift
      notes_backup "$@"
      ;;
    notes_api_empty_notes|api_empty_notes)
      shift
      notes_api_empty_notes "$@"
      ;;
    notes_api_list_todos|api_list_todos)
      shift
      notes_api_list_todos "$@"
      ;;
    print_todo_categories)
      shift
      print_todo_categories "$@"
      ;;
    notes_api_git|api_git)
      shift
      notes_api_git "$@"
      ;;
    notes_api_clone|api_clone)
      shift
      notes_api_clone "$@"
      ;;
    notes_api_fsck|api_fsck)
      shift
      notes_api_fsck "$@"
      ;;
    nw)
      shift
      nw "$@"
      ;;
    notes_window|window)
      shift
      notes_window "$@"
      ;;
    notes_api_find|api_find)
      shift
      notes_api_find "$@"
      ;;
    notes_api_quick_title|api_quick_title)
      shift
      notes_api_quick_title "$@"
      ;;
    notes_log|log)
      shift
      notes_log "$@"
      ;;
    notes_api_match_files|api_match_files)
      shift
      notes_api_match_files "$@"
      ;;
    notes_ls|ls)
      shift
      notes_ls "$@"
      ;;
    notes_hist|hist)
      shift
      notes_hist "$@"
      ;;
    notes_api_drop_note|api_drop_note)
      shift
      notes_api_drop_note "$@"
      ;;
    notes_gc|gc)
      shift
      notes_gc "$@"
      ;;
    notes_api_update_note|api_update_note)
      shift
      notes_api_update_note "$@"
      ;;
    notes_api_edit_note|api_edit_note)
      shift
      notes_api_edit_note "$@"
      ;;
    notes_api_perl_preview|api_perl_preview)
      shift
      notes_api_perl_preview "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module notes has no function $1"
      fi
      __q_help notes
      return 1
      ;;
    esac
    ;;
  omdb)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "omdb" "$@"
      ;;
    omdb_set_key|set_key)
      shift
      omdb_set_key "$@"
      ;;
    omdb_register_key|register_key)
      shift
      omdb_register_key "$@"
      ;;
    omdb_get_key|get_key)
      shift
      omdb_get_key "$@"
      ;;
    omdb_query|query)
      shift
      omdb_query "$@"
      ;;
    omdb_guess_title|guess_title)
      shift
      omdb_guess_title "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module omdb has no function $1"
      fi
      __q_help omdb
      return 1
      ;;
    esac
    ;;
  path)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "path" "$@"
      ;;
    path_expand|expand)
      shift
      path_expand "$@"
      ;;
    path_push|push)
      shift
      path_push "$@"
      ;;
    path_pop|pop)
      shift
      path_pop "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module path has no function $1"
      fi
      __q_help path
      return 1
      ;;
    esac
    ;;
  pkg)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "pkg" "$@"
      ;;
    pkg_install_or_skip|install_or_skip)
      shift
      pkg_install_or_skip "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module pkg has no function $1"
      fi
      __q_help pkg
      return 1
      ;;
    esac
    ;;
  python)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "python" "$@"
      ;;
    venv)
      shift
      venv "$@"
      ;;
    ipynb)
      shift
      ipynb "$@"
      ;;
    detect_python)
      shift
      detect_python "$@"
      ;;
    latest_python)
      shift
      latest_python "$@"
      ;;
    python_func|func)
      shift
      python_func "$@"
      ;;
    python_black|black)
      shift
      python_black "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module python has no function $1"
      fi
      __q_help python
      return 1
      ;;
    esac
    ;;
  quick)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "quick" "$@"
      ;;
    quick_rebuild|rebuild)
      shift
      quick_rebuild "$@"
      ;;
    q)
      shift
      q "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module quick has no function $1"
      fi
      __q_help quick
      return 1
      ;;
    esac
    ;;
  rust)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "rust" "$@"
      ;;
    rustup)
      shift
      rustup "$@"
      ;;
    rust_install_goodies|install_goodies)
      shift
      rust_install_goodies "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module rust has no function $1"
      fi
      __q_help rust
      return 1
      ;;
    esac
    ;;
  screen)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "screen" "$@"
      ;;
    screen_session|session)
      shift
      screen_session "$@"
      ;;
    screen_window|window)
      shift
      screen_window "$@"
      ;;
    screen_rename|rename)
      shift
      screen_rename "$@"
      ;;
    screen_home|home)
      shift
      screen_home "$@"
      ;;
    screen_reset_dirname|reset_dirname)
      shift
      screen_reset_dirname "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module screen has no function $1"
      fi
      __q_help screen
      return 1
      ;;
    esac
    ;;
  strings)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "strings" "$@"
      ;;
    strings_urlencode|urlencode)
      shift
      strings_urlencode "$@"
      ;;
    strip_control)
      shift
      strip_control "$@"
      ;;
    repeat)
      shift
      repeat "$@"
      ;;
    strings_join|join)
      shift
      strings_join "$@"
      ;;
    sgrep)
      shift
      sgrep "$@"
      ;;
    strings_strip_prefix|strip_prefix)
      shift
      strings_strip_prefix "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module strings has no function $1"
      fi
      __q_help strings
      return 1
      ;;
    esac
    ;;
  time)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "time" "$@"
      ;;
    file_mtime)
      shift
      file_mtime "$@"
      ;;
    file_age)
      shift
      file_age "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module time has no function $1"
      fi
      __q_help time
      return 1
      ;;
    esac
    ;;
  util)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "util" "$@"
      ;;
    sud)
      shift
      sud "$@"
      ;;
    reload)
      shift
      reload "$@"
      ;;
    markdown)
      shift
      markdown "$@"
      ;;
    human_size)
      shift
      human_size "$@"
      ;;
    install_heroku_cli)
      shift
      install_heroku_cli "$@"
      ;;
    bazel)
      shift
      bazel "$@"
      ;;
    jup)
      shift
      jup "$@"
      ;;
    wait_for_file)
      shift
      wait_for_file "$@"
      ;;
    forex)
      shift
      forex "$@"
      ;;
    trim)
      shift
      trim "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module util has no function $1"
      fi
      __q_help util
      return 1
      ;;
    esac
    ;;
  xterm_colors)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "xterm_colors" "$@"
      ;;
    channel_step)
      shift
      channel_step "$@"
      ;;
    greyscale_step)
      shift
      greyscale_step "$@"
      ;;
    rgb_to_xterm)
      shift
      rgb_to_xterm "$@"
      ;;
    hue_diff)
      shift
      hue_diff "$@"
      ;;
    brightness)
      shift
      brightness "$@"
      ;;
    contrast)
      shift
      contrast "$@"
      ;;
    xterm_to_rgb)
      shift
      xterm_to_rgb "$@"
      ;;
    xterm_to_fg)
      shift
      xterm_to_fg "$@"
      ;;
    xterm_to_bg)
      shift
      xterm_to_bg "$@"
      ;;
    tfmt)
      shift
      tfmt "$@"
      ;;
    color)
      shift
      color "$@"
      ;;
    shades)
      shift
      shades "$@"
      ;;
    colors)
      shift
      colors "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module xterm_colors has no function $1"
      fi
      __q_help xterm_colors
      return 1
      ;;
    esac
    ;;
  *)
    echo "Unknown module $1"
    return 1
    ;;
  esac
}

function __q_help() {
  if [ "$#" -eq 0 ]; then
    echo "q - redshell function registry"
    echo "Usage: q [-h|--help] MODULE FUNCTION [ARG...]"
    echo "Run q --help MODULE for more information on a module."
    echo
    echo "Available modules:"
    tput bold
    echo -n '  ascii_art'
    tput sgr0
    echo '         Assorted ascii art, screen drawing and speech bubbles.'
    tput bold
    echo -n '  bash'
    tput sgr0
    echo '              Parse bash files and automate bash scripting.'
    tput bold
    echo -n '  browser'
    tput sgr0
    echo '           Browser automation, downloads, link generators.'
    tput bold
    echo -n '  crypt'
    tput sgr0
    echo '             Encrypt/decrypt, signing, keypairs. SSH and GPG helpers.'
    tput bold
    echo -n '  fedora'
    tput sgr0
    echo '            Fedora setup and package management.'
    tput bold
    echo -n '  find'
    tput sgr0
    echo '              Shorthands for find and grep.'
    tput bold
    echo -n '  git'
    tput sgr0
    echo '               Automate git and github operations.'
    tput bold
    echo -n '  go'
    tput sgr0
    echo '                Helpers for dealing with Go packages.'
    tput bold
    echo -n '  hg'
    tput sgr0
    echo '                Mercurial helpers.'
    tput bold
    echo -n '  install'
    tput sgr0
    echo '           Install a file into another file, optionally with a keyword.'
    tput bold
    echo -n '  keys'
    tput sgr0
    echo '              Password manager based on pass and gpg.'
    tput bold
    echo -n '  mac'
    tput sgr0
    echo '               Mac setup, package management and various helpers.'
    tput bold
    echo -n '  media'
    tput sgr0
    echo '             Functions for working with media, ffmpeg, youtube, etc.'
    tput bold
    echo -n '  monitor'
    tput sgr0
    echo '           System load monitoring and logging.'
    tput bold
    echo -n '  mtg'
    tput sgr0
    echo '               Stuff for Magic: The Gathering.'
    tput bold
    echo -n '  multiple_choice'
    tput sgr0
    echo '   Interactive multiple choice prompts.'
    tput bold
    echo -n '  net'
    tput sgr0
    echo '               Network and wifi helpers, netcat wrappers, etc.'
    tput bold
    echo -n '  notes'
    tput sgr0
    echo '             Note management based on git and markdown.'
    tput bold
    echo -n '  omdb'
    tput sgr0
    echo '              IMDB (and actually open movie database) helpers for bash.'
    tput bold
    echo -n '  path'
    tput sgr0
    echo '              UNIX style path helpers.'
    tput bold
    echo -n '  pkg'
    tput sgr0
    echo '               Cross-platform package management.'
    tput bold
    echo -n '  python'
    tput sgr0
    echo '            Python env management, python-shell FFI and Jupyter.'
    tput bold
    echo -n '  quick'
    tput sgr0
    echo '             Redshell function help, switch and autocomplete.'
    tput bold
    echo -n '  rust'
    tput sgr0
    echo '              Manage rust toolchain and environment.'
    tput bold
    echo -n '  screen'
    tput sgr0
    echo '            UNIX style path helpers.'
    tput bold
    echo -n '  strings'
    tput sgr0
    echo '           String helpers for bash.'
    tput bold
    echo -n '  time'
    tput sgr0
    echo '              Time and date helpers.'
    tput bold
    echo -n '  util'
    tput sgr0
    echo '              Catch-all utility functions that don'"'"'t fit anywhere else.'
    tput bold
    echo -n '  xterm_colors'
    tput sgr0
    echo '      Work with the xterm color space, convert to RGB, etc.'
    return 0
  fi
  if [ "$#" -eq 1 ]; then
    case "$1" in
    ascii_art)
      echo "Usage: q ascii_art FUNCTION [ARG...]"
      echo "Assorted ascii art, screen drawing and speech bubbles."
      echo
      echo "Available functions:"
      tput bold
      echo "  q ascii_art print_speech_bubble [ARG...]"
      tput sgr0
      tput bold
      echo "  q ascii_art erase_lines [ARG...]"
      tput sgr0
      tput bold
      echo "  q ascii_art cursor_position [ARG...]"
      tput sgr0
      tput bold
      echo "  q ascii_art cursor_row [ARG...]"
      tput sgr0
      tput bold
      echo "  q ascii_art print_bmo [ARG...]"
      tput sgr0
      tput bold
      echo "  q ascii_art print_pedro [ARG...]"
      tput sgr0
      tput bold
      echo "  q ascii_art scroll_output_pedro [ARG...]"
      tput sgr0
      tput bold
      echo "  q ascii_art select_visual [ARG...]"
      tput sgr0
      ;;
    bash)
      echo "Usage: q bash FUNCTION [ARG...]"
      echo "Parse bash files and automate bash scripting."
      echo
      echo "Available functions:"
      tput bold
      echo "  q bash get_bash_functions [ARG...]"
      tput sgr0
      ;;
    browser)
      echo "Usage: q browser FUNCTION [ARG...]"
      echo "Browser automation, downloads, link generators."
      echo
      echo "Available functions:"
      tput bold
      echo "  q browser gdocs_id [ARG...]"
      tput sgr0
      tput bold
      echo "  q browser sheets_dl_link [ARG...]"
      tput sgr0
      tput bold
      echo "  q browser chrome_path [ARG...]"
      tput sgr0
      tput bold
      echo "  q browser downloads_path [ARG...]"
      tput sgr0
      tput bold
      echo "  q browser dl URL"
      tput sgr0
      echo '    Downloads a URL with the browser and returns the path to the downloaded file.'
      echo '    This is finnicky and relies on the browser downloading to the default'
      echo '    Downloads folder. If multiple new files are created around the same time, this'
      echo '    might behave in unpredictable ways. You'"'"'ve been warned.'
      ;;
    crypt)
      echo "Usage: q crypt FUNCTION [ARG...]"
      echo "Encrypt/decrypt, signing, keypairs. SSH and GPG helpers."
      echo
      echo "Available functions:"
      tput bold
      echo "  q crypt encrypt_symmetric FILE"
      tput sgr0
      tput bold
      echo "  q crypt decrypt_symmetric FILE"
      tput sgr0
      tput bold
      echo "  q crypt gen_github_keypair [ARG...]"
      tput sgr0
      tput bold
      echo "  q crypt package [ARG...]"
      tput sgr0
      tput bold
      echo "  q crypt payloadify FILE"
      tput sgr0
      tput bold
      echo "  q crypt downloadify FILE"
      tput sgr0
      echo '    Encrypt a file and wrap it in a base64 self-unpacking shell script.'
      tput bold
      echo "  q crypt hash ALGO [INPUT]"
      tput sgr0
      echo '    Print a cryptographic hash of the input.'
      echo '    '
      echo '    If no INPUT is provided, read from stdin.'
      echo '    '
      echo '    hash 256 foo -> b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c'
      echo '    hash md5 foo -> d3b07384d113edec49eaa6238ad5ff00'
      ;;
    fedora)
      echo "Usage: q fedora FUNCTION [ARG...]"
      echo "Fedora setup and package management."
      echo
      echo "Available functions:"
      tput bold
      echo "  q fedora setup [ARG...]"
      tput sgr0
      tput bold
      echo "  q fedora dnf_install_or_skip package1 package2 ..."
      tput sgr0
      echo '    Install a package with dnf if it'"'"'s not already installed.'
      ;;
    find)
      echo "Usage: q find FUNCTION [ARG...]"
      echo "Shorthands for find and grep."
      echo
      echo "Available functions:"
      tput bold
      echo "  q find f [ARG...]"
      tput sgr0
      echo '    Shorthand for find'
      tput bold
      echo "  q find fcc [ARG...]"
      tput sgr0
      tput bold
      echo "  q find fgo [ARG...]"
      tput sgr0
      tput bold
      echo "  q find fjava [ARG...]"
      tput sgr0
      tput bold
      echo "  q find faidl [ARG...]"
      tput sgr0
      tput bold
      echo "  q find fd [ARG...]"
      tput sgr0
      ;;
    git)
      echo "Usage: q git FUNCTION [ARG...]"
      echo "Automate git and github operations."
      echo
      echo "Available functions:"
      tput bold
      echo "  q git mkproject [ARG...]"
      tput sgr0
      tput bold
      echo "  q git git-ssh-init [ARG...]"
      tput sgr0
      ;;
    go)
      echo "Usage: q go FUNCTION [ARG...]"
      echo "Helpers for dealing with Go packages."
      echo
      echo "Available functions:"
      tput bold
      echo "  q go pkg_do [ARG...]"
      tput sgr0
      ;;
    hg)
      echo "Usage: q hg FUNCTION [ARG...]"
      echo "Mercurial helpers."
      echo
      echo "Available functions:"
      tput bold
      echo "  q hg root [ARG...]"
      tput sgr0
      echo '    Is the current directory a mercurial repo? Fast check. Prints the path to the'
      echo '    repo root, or nothing.'
      ;;
    init)
      echo "Usage: q init FUNCTION [ARG...]"
      echo "Initialization routines."
      echo
      echo "Available functions:"
      ;;
    install)
      echo "Usage: q install FUNCTION [ARG...]"
      echo "Install a file into another file, optionally with a keyword."
      echo
      echo "Available functions:"
      tput bold
      echo "  q install reinstall_file [ARG...]"
      tput sgr0
      tput bold
      echo "  q install file [ARG...]"
      tput sgr0
      tput bold
      echo "  q install uninstall_file [ARG...]"
      tput sgr0
      ;;
    keys)
      echo "Usage: q keys FUNCTION [ARG...]"
      echo "Password manager based on pass and gpg."
      echo
      echo "Available functions:"
      tput bold
      echo "  q keys git [ARGS ...]"
      tput sgr0
      echo '    Wraps git for use with the keys repository.'
      tput bold
      echo "  q keys path [-f] KEY"
      tput sgr0
      echo '    Dumps the contents of the given key in a file and returns the path.'
      tput bold
      echo "  q keys var KEY"
      tput sgr0
      echo '    Returns the conents of a given key in pass.'
      ;;
    mac)
      echo "Usage: q mac FUNCTION [ARG...]"
      echo "Mac setup, package management and various helpers."
      echo
      echo "Available functions:"
      tput bold
      echo "  q mac setup [ARG...]"
      tput sgr0
      tput bold
      echo "  q mac brew [ARG...]"
      tput sgr0
      tput bold
      echo "  q mac get_user_shell [ARG...]"
      tput sgr0
      tput bold
      echo "  q mac brew_bash_path [ARG...]"
      tput sgr0
      tput bold
      echo "  q mac switch_to_bash [ARG...]"
      tput sgr0
      tput bold
      echo "  q mac icloud [ARG...]"
      tput sgr0
      tput bold
      echo "  q mac icloud_evict [ARG...]"
      tput sgr0
      tput bold
      echo "  q mac brew_install_or_skip [ARG...]"
      tput sgr0
      tput bold
      echo "  q mac install_miniconda [ARG...]"
      tput sgr0
      tput bold
      echo "  q mac install_devtools [ARG...]"
      tput sgr0
      tput bold
      echo "  q mac kill_defender "
      tput sgr0
      echo '    Kills Microsoft Defender in a way that tends to persist for an hour or so.'
      echo '    This is useful for working around bugs or surviving when they push and update'
      echo '    that breaks the OS.'
      echo '    '
      echo '    Use at your own risk, and only after discussing with your IT department. This'
      echo '    action is likely to be detected.'
      tput bold
      echo "  q mac suppress_defender "
      tput sgr0
      echo '    Keeps Microsoft Defender from restarting.'
      echo '    '
      echo '    Use at your own risk, and only after discussing with your IT department. This'
      echo '    action is likely to be detected.'
      tput bold
      echo "  q mac kill_crashplan "
      tput sgr0
      echo '    Stops CrashPlan from running. CrashPlan is a very poorly optimized backup'
      echo '    service. When you'"'"'re running IO intensive workloads, it can slow them down'
      echo '    massively and eat up 2-3 CPU cores.'
      ;;
    media)
      echo "Usage: q media FUNCTION [ARG...]"
      echo "Functions for working with media, ffmpeg, youtube, etc."
      echo
      echo "Available functions:"
      tput bold
      echo "  q media yt-dl [OPTIONS ...] URL"
      tput sgr0
      echo '    Wrapper areound yt-dlp. Automatically ensures dependencies are installed.'
      ;;
    monitor)
      echo "Usage: q monitor FUNCTION [ARG...]"
      echo "System load monitoring and logging."
      echo
      echo "Available functions:"
      tput bold
      echo "  q monitor stream_load_stats [ARG...]"
      tput sgr0
      tput bold
      echo "  q monitor load_hist [ARG...]"
      tput sgr0
      tput bold
      echo "  q monitor latest_load_stats [ARG...]"
      tput sgr0
      tput bold
      echo "  q monitor write_load_stats [ARG...]"
      tput sgr0
      tput bold
      echo "  q monitor stream_top_stats [ARG...]"
      tput sgr0
      tput bold
      echo "  q monitor stream_net_stats [ARG...]"
      tput sgr0
      tput bold
      echo "  q monitor proc_stats [ARG...]"
      tput sgr0
      echo '    Outputs:'
      echo '    1. CPU util'
      echo '    2. Physical RAM util'
      echo '    3. Total RSS'
      echo '    4. User time total'
      echo '    5. System time total'
      echo '    6. PID with the highest CPU util'
      echo '    7. Comm with the highest CPU util'
      echo '    8. CPU util of the proc with the highest CPU util'
      echo '    9. PID with the highest RSS'
      echo '    10. Comm with the highest RSS'
      echo '    11. RSS of the proc with the highest RSS'
      ;;
    mtg)
      echo "Usage: q mtg FUNCTION [ARG...]"
      echo "Stuff for Magic: The Gathering."
      echo
      echo "Available functions:"
      tput bold
      echo "  q mtg oracle_json "
      tput sgr0
      echo '    Fetch the latest oracle cards from Scryfall and return the path to the JSON'
      echo '    dump. The dump is cached for about two weeks.'
      tput bold
      echo "  q mtg rules [ARG...]"
      tput sgr0
      tput bold
      echo "  q mtg card_json NAME"
      tput sgr0
      echo '    Return the JSON object for the card with the given name. (Case sensitive.)'
      tput bold
      echo "  q mtg card NAME"
      tput sgr0
      echo '    Print the Magic: The Gathering card with the given name. (Case sensitive.)'
      ;;
    multiple_choice)
      echo "Usage: q multiple_choice FUNCTION [ARG...]"
      echo "Interactive multiple choice prompts."
      echo
      echo "Available functions:"
      tput bold
      echo "  q multiple_choice multiple_choice [-n|-L] [-i INPUT] [-p PAGE] [-m MSG] [-a ALPHABET] [-I CONTROLS] [-A CONTROL_ALPHABET]"
      tput sgr0
      echo '    Display an interactive menu with multiple choices, and then print the selected option to stdout.'
      echo '    '
      echo '    -n: return the number of the selected option'
      echo '    -L: return the string of the selected option'
      echo '    -p: page number to show'
      echo '    -m: prompt message'
      echo '    -a: alphabet'
      echo '    -I: control options'
      echo '    -A: control alphabet'
      echo '    -i: input (options to pick from)'
      ;;
    net)
      echo "Usage: q net FUNCTION [ARG...]"
      echo "Network and wifi helpers, netcat wrappers, etc."
      echo
      echo "Available functions:"
      tput bold
      echo "  q net dataurl [ARG...]"
      tput sgr0
      echo '    Create a data URL from a file'
      tput bold
      echo "  q net rtt [ARG...]"
      tput sgr0
      echo '    Average round-trip time to the specified host.'
      tput bold
      echo "  q net ip4 [ARG...]"
      tput sgr0
      echo '    Print the non-localhost IPv4 addresses of this machine. One address per line.'
      tput bold
      echo "  q net ip4gw [ARG...]"
      tput sgr0
      tput bold
      echo "  q net serve [ARG...]"
      tput sgr0
      tput bold
      echo "  q net dump_url [ARG...]"
      tput sgr0
      tput bold
      echo "  q net wiki [ARG...]"
      tput sgr0
      tput bold
      echo "  q net wifi_device [ARG...]"
      tput sgr0
      tput bold
      echo "  q net wifi_name [ARG...]"
      tput sgr0
      tput bold
      echo "  q net ssh_fingerprint HOST"
      tput sgr0
      ;;
    notes)
      echo "Usage: q notes FUNCTION [ARG...]"
      echo "Note management based on git and markdown."
      echo
      echo "Available functions:"
      tput bold
      echo "  q notes note [NOTE]"
      tput sgr0
      echo '    Saves the provided note, intelligently placing it and generating a title. If'
      echo '    run with no arguments, instead opens vim and saves whatever is entered into'
      echo '    the file.'
      tput bold
      echo "  q notes list [ARG...]"
      tput sgr0
      tput bold
      echo "  q notes sync [ARG...]"
      tput sgr0
      tput bold
      echo "  q notes todo [TERM ...]"
      tput sgr0
      echo '    Shows an interactive listing of matching TODOs.'
      echo '    '
      echo '    Uses the following categories:'
      echo '    A - üí¨ - Asynchronous Comms'
      echo '    B - üí∞ - Bank'
      echo '    C - üìÖ - Calendar'
      echo '    E - üèÉ - Errand'
      echo '    H - üè† - Home'
      echo '    M - üë• - Meeting'
      echo '    L - üí© - Long Task'
      echo '    O - üëî - Office'
      echo '    R - üìö - Reading'
      echo '    S - üõí - Shopping'
      echo '    T - üìû - Telephone'
      echo '    W - üìù - Writing'
      echo '    X - üõ†Ô∏è - Technical Task'
      echo '    Z - ‚è© - Misc Quick Task'
      echo '    üì• - Inbox'
      tput bold
      echo "  q notes undo [-f]"
      tput sgr0
      echo '    Undoes the last note change. If the last change was to a local note, it will'
      echo '    refuse to undo it, unless -f is passed.'
      tput bold
      echo "  q notes perl PROG [TERM ...]"
      tput sgr0
      echo '    Applies the provided perl program to matching notes to generate replacements.'
      echo '    Then allows the user to select which replacements to save.'
      tput bold
      echo "  q notes api_list_notes notes_api_match_files [-f] [-a] [TERM ...]"
      tput sgr0
      echo '    Outputs a list of notes files that match the given terms.'
      echo '    '
      echo '    Options:'
      echo '    -f: Only match files, not directories.'
      echo '    -a: Include archived files.'
      echo '    '
      echo '    Outputs:'
      echo '    1. relative path'
      echo '    2. mtime'
      echo '    3. age'
      echo '    4. line count'
      echo '    5. depth'
      echo '    6. absolute path'
      echo '    7. type (f or d)'
      echo '    8. title'
      echo '    9. location (g=git or l=local)'
      echo '    10. base path'
      echo '    11. Quick-TODO-aware title'
      echo '    12. Archived (A if archived - if not)'
      tput bold
      echo "  q notes backup "
      tput sgr0
      echo '    Backs up the notes repository to a timestamped tarball in the notes root.'
      tput bold
      echo "  q notes api_empty_notes notes_api_edit_notes"
      tput sgr0
      echo '    Lists empty notes.'
      tput bold
      echo "  q notes api_list_todos [CONTEXT] [TERM ...]"
      tput sgr0
      echo '    Lists TODOs matching the given context and terms.'
      echo '    '
      echo '    Outputs:'
      echo '    '
      echo '    1. Path'
      echo '    2. Line number'
      echo '    3. State (TODO or DONE)'
      echo '    4. Text of the TODO'
      echo '    5. Absolute path'
      echo '    6. File age'
      echo '    7. File mtime'
      echo '    8. Current state: TODO|DONE|LATER|OVERDUE|SOON'
      echo '    9. Earliest date (if any)'
      echo '    10. Due date (if any)'
      echo '    11. Context (one letter)'
      tput bold
      echo "  q notes print_todo_categories [ARG...]"
      tput sgr0
      tput bold
      echo "  q notes api_git [ARGS ...]"
      tput sgr0
      echo '    Forwards its args to git running with the correct key and in the notes root.'
      tput bold
      echo "  q notes api_clone "
      tput sgr0
      echo '    Clones the git reposity.'
      tput bold
      echo "  q notes api_fsck [ARG...]"
      tput sgr0
      echo '    Resets the mtime of notes files from git.'
      tput bold
      echo "  q notes nw [ARG...]"
      tput sgr0
      tput bold
      echo "  q notes window [ARG...]"
      tput sgr0
      tput bold
      echo "  q notes api_find [ARG...]"
      tput sgr0
      echo '    Runs find automatically scoped to the right mtime by the NEND and NSTART env'
      echo '    variables.'
      tput bold
      echo "  q notes api_quick_title [ARG...]"
      tput sgr0
      tput bold
      echo "  q notes log [ARG...]"
      tput sgr0
      tput bold
      echo "  q notes api_match_files [ARG...]"
      tput sgr0
      echo '    Returns a list of files, as absolute paths, that match a search query. The'
      echo '    query is a list of terms, separated by spaces. Each term is either a'
      echo '    pro-pattern, or an anti-pattern:'
      echo '    '
      echo '    Pro-pattern terms are regular words (e.g. '"'"'foo'"'"') that MUST appear in the file.'
      echo '    If there are multiple pro-pattern terms, then they all must appear for a file'
      echo '    to match (match all).'
      echo '    '
      echo '    Anti-pattern terms start with a tilde `~` (e.g. `~bar`). Any file containing'
      echo '    even one of the anti-pattern terms is excluded from the results.'
      echo '    '
      echo '    Without any pro-patterns, starts with matching all files.'
      echo '    '
      echo '    Additional flags start with a dash '"'"'-'"'"', to be supplied in any position:'
      echo '    '
      echo '    -w match only complete words (DEFAULT) -W match substrings'
      tput bold
      echo "  q notes ls notes_list [TERM ...]"
      tput sgr0
      echo '    Prints a tree of notes, with the TERM as a filter.'
      tput bold
      echo "  q notes hist [N]"
      tput sgr0
      echo '    Prints the N most recent notes.'
      tput bold
      echo "  q notes api_drop_note NOTE"
      tput sgr0
      echo '    Delete the note at the provided relative path.'
      tput bold
      echo "  q notes gc "
      tput sgr0
      echo '    Deletes empty notes and runs git gc.'
      tput bold
      echo "  q notes api_update_note RELPATH CONTENTS"
      tput sgr0
      echo '    Updates the note at the given relative path with the given contents.'
      tput bold
      echo "  q notes api_edit_note PATH [LINE]"
      tput sgr0
      echo '    Opens vim for the given relative note path, then updates the notes tree using'
      echo '    the result. Optional second argument is the line number to open vim at.'
      tput bold
      echo "  q notes api_perl_preview PROG [TERM ...]"
      tput sgr0
      echo '    Applies the provided perl program to matching notes to generate replacements.'
      echo '    Returns the potential replacements.'
      ;;
    omdb)
      echo "Usage: q omdb FUNCTION [ARG...]"
      echo "IMDB (and actually open movie database) helpers for bash."
      echo
      echo "Available functions:"
      tput bold
      echo "  q omdb set_key KEY"
      tput sgr0
      tput bold
      echo "  q omdb register_key "
      tput sgr0
      tput bold
      echo "  q omdb get_key "
      tput sgr0
      tput bold
      echo "  q omdb query [-f] [QUERY ...]"
      tput sgr0
      echo '    Query the OMDB API with the given query. Prints JSON to stdout. Results are'
      echo '    cached. Use -f to force a fresh query.'
      echo '    '
      echo '    The query consists of a series of PARAMETER=QUERY pairs. Valid parameters are'
      echo '    documented at http://www.omdbapi.com.'
      echo '    '
      echo '    Examples:'
      echo '    q omdb query "t=The Matrix"'
      echo '    q omdb query "i=tt0133093"'
      echo '    '
      echo '    Useful parameters include:'
      echo '    '
      echo '    - t: Title of the movie.'
      echo '    - i: IMDB ID of the movie.'
      tput bold
      echo "  q omdb guess_title FILE"
      tput sgr0
      echo '    Guess the title of the movie based on the filename.'
      ;;
    path)
      echo "Usage: q path FUNCTION [ARG...]"
      echo "UNIX style path helpers."
      echo
      echo "Available functions:"
      tput bold
      echo "  q path expand PATH"
      tput sgr0
      echo '    Expands tilde, safely, in the path.'
      tput bold
      echo "  q path push DIRECTORY"
      tput sgr0
      echo '    This is like pushd, except it also updates the name of the screen window to'
      echo '    the new path, if run from inside a screen session.'
      tput bold
      echo "  q path pop [ARG...]"
      tput sgr0
      ;;
    pkg)
      echo "Usage: q pkg FUNCTION [ARG...]"
      echo "Cross-platform package management."
      echo
      echo "Available functions:"
      tput bold
      echo "  q pkg install_or_skip [PACKAGE...]"
      tput sgr0
      echo '    Install packages using the system package manager, or skip, if the package is'
      echo '    already installed.'
      ;;
    python)
      echo "Usage: q python FUNCTION [ARG...]"
      echo "Python env management, python-shell FFI and Jupyter."
      echo
      echo "Available functions:"
      tput bold
      echo "  q python venv [ARG...]"
      tput sgr0
      tput bold
      echo "  q python ipynb [ARG...]"
      tput sgr0
      tput bold
      echo "  q python detect_python [ARG...]"
      tput sgr0
      tput bold
      echo "  q python latest_python [ARG...]"
      tput sgr0
      tput bold
      echo "  q python func -f|--function FUNCTION -p|--path PATH [-J|--json_output] [--clean] [--debug] [--] [ARGS...]"
      tput sgr0
      tput bold
      echo "  q python black [FILES...]"
      tput sgr0
      ;;
    quick)
      echo "Usage: q quick FUNCTION [ARG...]"
      echo "Redshell function help, switch and autocomplete."
      echo
      echo "Available functions:"
      tput bold
      echo "  q quick rebuild [--src-path PATH] [--skip-extra-paths]"
      tput sgr0
      tput bold
      echo "  q quick q [ARG...]"
      tput sgr0
      ;;
    rust)
      echo "Usage: q rust FUNCTION [ARG...]"
      echo "Manage rust toolchain and environment."
      echo
      echo "Available functions:"
      tput bold
      echo "  q rust rustup [ARG...]"
      tput sgr0
      tput bold
      echo "  q rust install_goodies [ARG...]"
      tput sgr0
      ;;
    screen)
      echo "Usage: q screen FUNCTION [ARG...]"
      echo "UNIX style path helpers."
      echo
      echo "Available functions:"
      tput bold
      echo "  q screen session [ARG...]"
      tput sgr0
      tput bold
      echo "  q screen window [ARG...]"
      tput sgr0
      tput bold
      echo "  q screen rename [ARG...]"
      tput sgr0
      tput bold
      echo "  q screen home [ARG...]"
      tput sgr0
      tput bold
      echo "  q screen reset_dirname [ARG...]"
      tput sgr0
      ;;
    strings)
      echo "Usage: q strings FUNCTION [ARG...]"
      echo "String helpers for bash."
      echo
      echo "Available functions:"
      tput bold
      echo "  q strings urlencode [ARG...]"
      tput sgr0
      echo '    Usage strings_urlencode STRING'
      echo '    '
      echo '    URL-encodes a string. DO NOT USE with curl: prefer --data-urlencode.'
      tput bold
      echo "  q strings strip_control "
      tput sgr0
      echo '    Strips terminal escape sequences from standard input.'
      tput bold
      echo "  q strings repeat STRING N"
      tput sgr0
      echo '    Prints STRING N times.'
      tput bold
      echo "  q strings join DELIMITER [STRING ...]"
      tput sgr0
      tput bold
      echo "  q strings sgrep [-C NUM]"
      tput sgr0
      tput bold
      echo "  q strings strip_prefix [ARG...]"
      tput sgr0
      ;;
    time)
      echo "Usage: q time FUNCTION [ARG...]"
      echo "Time and date helpers."
      echo
      echo "Available functions:"
      tput bold
      echo "  q time file_mtime [ARG...]"
      tput sgr0
      tput bold
      echo "  q time file_age [-s] PATH"
      tput sgr0
      ;;
    util)
      echo "Usage: q util FUNCTION [ARG...]"
      echo "Catch-all utility functions that don't fit anywhere else."
      echo
      echo "Available functions:"
      tput bold
      echo "  q util sud [ARG...]"
      tput sgr0
      tput bold
      echo "  q util reload [ARG...]"
      tput sgr0
      tput bold
      echo "  q util markdown [ARG...]"
      tput sgr0
      tput bold
      echo "  q util human_size [-b|-bb|-S|-h|-hh] SIZE"
      tput sgr0
      echo '    Convert SIZE to human-readable format.'
      echo '    '
      echo '    -b: bits'
      echo '    -bb: SI units'
      echo '    -S: SI bytes'
      echo '    -h: base-2 bytes'
      echo '    -hh: base-2 bytes, no space between number and unit'
      echo '    '
      echo '    If no mode switch is specified then normal, base-2 byte units are used.'
      tput bold
      echo "  q util install_heroku_cli [ARG...]"
      tput sgr0
      tput bold
      echo "  q util bazel [ARG...]"
      tput sgr0
      tput bold
      echo "  q util jup [ARG...]"
      tput sgr0
      tput bold
      echo "  q util wait_for_file [ARG...]"
      tput sgr0
      tput bold
      echo "  q util forex [ARG...]"
      tput sgr0
      tput bold
      echo "  q util trim [ARG...]"
      tput sgr0
      ;;
    xterm_colors)
      echo "Usage: q xterm_colors FUNCTION [ARG...]"
      echo "Work with the xterm color space, convert to RGB, etc."
      echo
      echo "Available functions:"
      tput bold
      echo "  q xterm_colors channel_step [ARG...]"
      tput sgr0
      echo '    Takes one RGB channel value as a 2-byte hex string and returns a decimal'
      echo '    number representing the step in XTERM_CHANNEL_STEPS that'"'"'s the closest.'
      tput bold
      echo "  q xterm_colors greyscale_step [ARG...]"
      tput sgr0
      echo '    As channel_step, but for greyscale.'
      tput bold
      echo "  q xterm_colors rgb_to_xterm [ARG...]"
      tput sgr0
      echo '    Takes an RGB color as a 6-byte hex string and returns the closest xterm color.'
      tput bold
      echo "  q xterm_colors hue_diff [ARG...]"
      tput sgr0
      echo '    Computes the hue difference between two RGB colors passed as 6-byte hex'
      echo '    strings. Result is in the interval [0; 765]. Contrast values greater than ~400'
      echo '    are usually legible for text, if sufficient brightness contrast also exists.'
      echo '    (Depends on terminal.)'
      tput bold
      echo "  q xterm_colors brightness [ARG...]"
      tput sgr0
      echo '    Computes the brightness of an RGB color passed as a 6-byte hex string. Result'
      echo '    is in the interval [0; 255]. Brightness contrast of ~100 is usually legible if'
      echo '    sufficient hue contrast also exists. (Depends on terminal.)'
      tput bold
      echo "  q xterm_colors contrast [ARG...]"
      tput sgr0
      echo '    Computes a contrast value between two RGB colors passed as 6-byte hex strings.'
      echo '    Result is in the interval [0; 192]. Combines hue and brightness information.'
      echo '    Contrast values over 80 are usually legible, depending on terminal.'
      tput bold
      echo "  q xterm_colors xterm_to_rgb [ARG...]"
      tput sgr0
      echo '    Takes an xterm color number as a decimal integer and returns a 6-byte hex of'
      echo '    the RGB color.'
      tput bold
      echo "  q xterm_colors xterm_to_fg [ARG...]"
      tput sgr0
      tput bold
      echo "  q xterm_colors xterm_to_bg [ARG...]"
      tput sgr0
      tput bold
      echo "  q xterm_colors tfmt [ARG...]"
      tput sgr0
      tput bold
      echo "  q xterm_colors color [ARG...]"
      tput sgr0
      tput bold
      echo "  q xterm_colors shades [ARG...]"
      tput sgr0
      tput bold
      echo "  q xterm_colors colors [ARG...]"
      tput sgr0
      ;;
    *)
      echo "Unknown module $1"
      return 1
      ;;
    esac
  fi
}
function __q_dump() {
  if [[ ! "$#" -eq 2 ]]; then
    echo "Usage: q dump MODULE FUNCTION"
    return 1
  fi
  case "$1" in
  ascii_art)
    case "$2" in
    print_speech_bubble)
      type print_speech_bubble
      ;;
    erase_lines)
      type erase_lines
      ;;
    cursor_position)
      type cursor_position
      ;;
    cursor_row)
      type cursor_row
      ;;
    print_bmo)
      type print_bmo
      ;;
    print_pedro)
      type print_pedro
      ;;
    scroll_output_pedro)
      type scroll_output_pedro
      ;;
    select_visual)
      type select_visual
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  bash)
    case "$2" in
    get_bash_functions)
      type get_bash_functions
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  browser)
    case "$2" in
    gdocs_id)
      type gdocs_id
      ;;
    sheets_dl_link)
      type sheets_dl_link
      ;;
    chrome_path)
      type chrome_path
      ;;
    downloads_path)
      type downloads_path
      ;;
    dl)
      type browser_dl
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  crypt)
    case "$2" in
    encrypt_symmetric)
      type encrypt_symmetric
      ;;
    decrypt_symmetric)
      type decrypt_symmetric
      ;;
    gen_github_keypair)
      type gen_github_keypair
      ;;
    package)
      type package
      ;;
    payloadify)
      type payloadify
      ;;
    downloadify)
      type downloadify
      ;;
    hash)
      type crypt_hash
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  fedora)
    case "$2" in
    setup)
      type fedora_setup
      ;;
    dnf_install_or_skip)
      type dnf_install_or_skip
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  find)
    case "$2" in
    f)
      type f
      ;;
    __f_args)
      type __f_args
      ;;
    fcc)
      type fcc
      ;;
    fgo)
      type fgo
      ;;
    fjava)
      type fjava
      ;;
    faidl)
      type faidl
      ;;
    fd)
      type fd
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  git)
    case "$2" in
    mkproject)
      type mkproject
      ;;
    git-ssh-init)
      type git-ssh-init
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  go)
    case "$2" in
    pkg_do)
      type go_pkg_do
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  hg)
    case "$2" in
    root)
      type hg_root
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  init)
    case "$2" in
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  install)
    case "$2" in
    reinstall_file)
      type reinstall_file
      ;;
    file)
      type install_file
      ;;
    uninstall_file)
      type uninstall_file
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  keys)
    case "$2" in
    git)
      type keys_git
      ;;
    path)
      type keys_path
      ;;
    var)
      type keys_var
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  mac)
    case "$2" in
    setup)
      type mac_setup
      ;;
    brew)
      type brew
      ;;
    get_user_shell)
      type mac_get_user_shell
      ;;
    brew_bash_path)
      type mac_brew_bash_path
      ;;
    switch_to_bash)
      type mac_switch_to_bash
      ;;
    icloud)
      type icloud
      ;;
    icloud_evict)
      type icloud_evict
      ;;
    brew_install_or_skip)
      type brew_install_or_skip
      ;;
    install_miniconda)
      type mac_install_miniconda
      ;;
    install_devtools)
      type mac_install_devtools
      ;;
    kill_defender)
      type mac_kill_defender
      ;;
    suppress_defender)
      type mac_suppress_defender
      ;;
    kill_crashplan)
      type mac_kill_crashplan
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  media)
    case "$2" in
    yt-dl)
      type yt-dl
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  monitor)
    case "$2" in
    __load_stats_worker)
      type __load_stats_worker
      ;;
    __stream_tick)
      type __stream_tick
      ;;
    stream_load_stats)
      type stream_load_stats
      ;;
    __write_load_stats_worker)
      type __write_load_stats_worker
      ;;
    load_hist)
      type load_hist
      ;;
    latest_load_stats)
      type latest_load_stats
      ;;
    __parse_load_stats)
      type __parse_load_stats
      ;;
    write_load_stats)
      type write_load_stats
      ;;
    stream_top_stats)
      type stream_top_stats
      ;;
    __parse_top_header)
      type __parse_top_header
      ;;
    __parse_units)
      type __parse_units
      ;;
    __stream_net_stats_worker)
      type __stream_net_stats_worker
      ;;
    __parse_nettop)
      type __parse_nettop
      ;;
    stream_net_stats)
      type stream_net_stats
      ;;
    proc_stats)
      type proc_stats
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  mtg)
    case "$2" in
    __mtg_latest_scryfall_oracle_cards_uri)
      type __mtg_latest_scryfall_oracle_cards_uri
      ;;
    oracle_json)
      type mtg_oracle_json
      ;;
    rules)
      type mtg_rules
      ;;
    card_json)
      type mtg_card_json
      ;;
    card)
      type mtg_card
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  multiple_choice)
    case "$2" in
    __prompt)
      type __prompt
      ;;
    __multiple_choice)
      type __multiple_choice
      ;;
    multiple_choice)
      type multiple_choice
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  net)
    case "$2" in
    dataurl)
      type dataurl
      ;;
    rtt)
      type rtt
      ;;
    ip4)
      type ip4
      ;;
    ip4gw)
      type ip4gw
      ;;
    serve)
      type serve
      ;;
    dump_url)
      type dump_url
      ;;
    wiki)
      type wiki
      ;;
    wifi_device)
      type wifi_device
      ;;
    wifi_name)
      type wifi_name
      ;;
    ssh_fingerprint)
      type net_ssh_fingerprint
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  notes)
    case "$2" in
    __elide)
      type __elide
      ;;
    __file_mtime_and_age)
      type __file_mtime_and_age
      ;;
    __notes_api_list_notes_batch)
      type __notes_api_list_notes_batch
      ;;
    note)
      type notes_note
      ;;
    list)
      type notes_list
      ;;
    sync)
      type notes_sync
      ;;
    todo)
      type notes_todo
      ;;
    undo)
      type notes_undo
      ;;
    perl)
      type notes_perl
      ;;
    api_list_notes)
      type notes_api_list_notes
      ;;
    __nonempty_wc_l)
      type __nonempty_wc_l
      ;;
    backup)
      type notes_backup
      ;;
    api_empty_notes)
      type notes_api_empty_notes
      ;;
    __date_add)
      type __date_add
      ;;
    __wday)
      type __wday
      ;;
    __date_sub)
      type __date_sub
      ;;
    __date_convert)
      type __date_convert
      ;;
    __wday_number)
      type __wday_number
      ;;
    __relative_moment)
      type __relative_moment
      ;;
    __when)
      type __when
      ;;
    __notes_api_list_todos_batch)
      type __notes_api_list_todos_batch
      ;;
    api_list_todos)
      type notes_api_list_todos
      ;;
    print_todo_categories)
      type print_todo_categories
      ;;
    __todo_context_emoji)
      type __todo_context_emoji
      ;;
    __select_todo)
      type __select_todo
      ;;
    api_git)
      type notes_api_git
      ;;
    api_clone)
      type notes_api_clone
      ;;
    __fix_mtime_from_git)
      type __fix_mtime_from_git
      ;;
    api_fsck)
      type notes_api_fsck
      ;;
    __date_unit)
      type __date_unit
      ;;
    __parse_age)
      type __parse_age
      ;;
    nw)
      type nw
      ;;
    window)
      type notes_window
      ;;
    api_find)
      type notes_api_find
      ;;
    api_quick_title)
      type notes_api_quick_title
      ;;
    __notes_filename)
      type __notes_filename
      ;;
    log)
      type notes_log
      ;;
    __match_files_one)
      type __match_files_one
      ;;
    __match_files_all)
      type __match_files_all
      ;;
    __match_files_regex)
      type __match_files_regex
      ;;
    api_match_files)
      type notes_api_match_files
      ;;
    __todo_title)
      type __todo_title
      ;;
    __notes_title)
      type __notes_title
      ;;
    __notes_category)
      type __notes_category
      ;;
    __preamble)
      type __preamble
      ;;
    ls)
      type notes_ls
      ;;
    hist)
      type notes_hist
      ;;
    api_drop_note)
      type notes_api_drop_note
      ;;
    __notes_gen)
      type __notes_gen
      ;;
    gc)
      type notes_gc
      ;;
    api_update_note)
      type notes_api_update_note
      ;;
    api_edit_note)
      type notes_api_edit_note
      ;;
    __notes_api_perl_preview_batch)
      type __notes_api_perl_preview_batch
      ;;
    api_perl_preview)
      type notes_api_perl_preview
      ;;
    __nperl_render_preview)
      type __nperl_render_preview
      ;;
    __nperl_apply)
      type __nperl_apply
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  omdb)
    case "$2" in
    __omdb_key_path)
      type __omdb_key_path
      ;;
    set_key)
      type omdb_set_key
      ;;
    register_key)
      type omdb_register_key
      ;;
    get_key)
      type omdb_get_key
      ;;
    __omdb_query_string)
      type __omdb_query_string
      ;;
    query)
      type omdb_query
      ;;
    guess_title)
      type omdb_guess_title
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  path)
    case "$2" in
    expand)
      type path_expand
      ;;
    push)
      type path_push
      ;;
    pop)
      type path_pop
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  pkg)
    case "$2" in
    install_or_skip)
      type pkg_install_or_skip
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  python)
    case "$2" in
    __python_ensurepip)
      type __python_ensurepip
      ;;
    __python_ensurevenv)
      type __python_ensurevenv
      ;;
    __fix_stupid_virtualenv_behavior)
      type __fix_stupid_virtualenv_behavior
      ;;
    venv)
      type venv
      ;;
    ipynb)
      type ipynb
      ;;
    detect_python)
      type detect_python
      ;;
    latest_python)
      type latest_python
      ;;
    func)
      type python_func
      ;;
    black)
      type python_black
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  quick)
    case "$2" in
    __quick_build_all)
      type __quick_build_all
      ;;
    rebuild)
      type quick_rebuild
      ;;
    q)
      type q
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  rust)
    case "$2" in
    rustup)
      type rustup
      ;;
    install_goodies)
      type rust_install_goodies
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  screen)
    case "$2" in
    session)
      type screen_session
      ;;
    window)
      type screen_window
      ;;
    rename)
      type screen_rename
      ;;
    home)
      type screen_home
      ;;
    reset_dirname)
      type screen_reset_dirname
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  strings)
    case "$2" in
    urlencode)
      type strings_urlencode
      ;;
    strip_control)
      type strip_control
      ;;
    repeat)
      type repeat
      ;;
    join)
      type strings_join
      ;;
    sgrep)
      type sgrep
      ;;
    strip_prefix)
      type strings_strip_prefix
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  time)
    case "$2" in
    file_mtime)
      type file_mtime
      ;;
    file_age)
      type file_age
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  util)
    case "$2" in
    sud)
      type sud
      ;;
    reload)
      type reload
      ;;
    markdown)
      type markdown
      ;;
    human_size)
      type human_size
      ;;
    install_heroku_cli)
      type install_heroku_cli
      ;;
    bazel)
      type bazel
      ;;
    jup)
      type jup
      ;;
    wait_for_file)
      type wait_for_file
      ;;
    forex)
      type forex
      ;;
    trim)
      type trim
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  xterm_colors)
    case "$2" in
    channel_step)
      type channel_step
      ;;
    greyscale_step)
      type greyscale_step
      ;;
    rgb_to_xterm)
      type rgb_to_xterm
      ;;
    hue_diff)
      type hue_diff
      ;;
    brightness)
      type brightness
      ;;
    contrast)
      type contrast
      ;;
    xterm_to_rgb)
      type xterm_to_rgb
      ;;
    xterm_to_fg)
      type xterm_to_fg
      ;;
    xterm_to_bg)
      type xterm_to_bg
      ;;
    tfmt)
      type tfmt
      ;;
    color)
      type color
      ;;
    shades)
      type shades
      ;;
    colors)
      type colors
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  *)
    echo "Unknown module $1"
    return 1
    ;;
  esac
}

function __q_compgen() {
  local modules="ascii_art bash browser crypt fedora find git go hg init install keys mac media monitor mtg multiple_choice net notes omdb path pkg python quick rust screen strings time util xterm_colors"
  case "${COMP_CWORD}" in
  1)
    COMPREPLY=($(compgen -W "help ${modules}" -- ${COMP_WORDS[COMP_CWORD]}))
    return 0
  ;;
  2)
    case "${COMP_WORDS[1]}" in
    ascii_art)
      COMPREPLY=($(compgen -W "help print_speech_bubble erase_lines cursor_position cursor_row print_bmo print_pedro scroll_output_pedro select_visual" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    bash)
      COMPREPLY=($(compgen -W "help get_bash_functions" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    browser)
      COMPREPLY=($(compgen -W "help gdocs_id sheets_dl_link chrome_path downloads_path dl" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    crypt)
      COMPREPLY=($(compgen -W "help encrypt_symmetric decrypt_symmetric gen_github_keypair package payloadify downloadify hash" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    fedora)
      COMPREPLY=($(compgen -W "help setup dnf_install_or_skip" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    find)
      COMPREPLY=($(compgen -W "help f fcc fgo fjava faidl fd" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    git)
      COMPREPLY=($(compgen -W "help mkproject git-ssh-init" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    go)
      COMPREPLY=($(compgen -W "help pkg_do" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    hg)
      COMPREPLY=($(compgen -W "help root" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    init)
      COMPREPLY=($(compgen -W "help " -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    install)
      COMPREPLY=($(compgen -W "help reinstall_file file uninstall_file" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    keys)
      COMPREPLY=($(compgen -W "help git path var" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    mac)
      COMPREPLY=($(compgen -W "help setup brew get_user_shell brew_bash_path switch_to_bash icloud icloud_evict brew_install_or_skip install_miniconda install_devtools kill_defender suppress_defender kill_crashplan" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    media)
      COMPREPLY=($(compgen -W "help yt-dl" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    monitor)
      COMPREPLY=($(compgen -W "help stream_load_stats load_hist latest_load_stats write_load_stats stream_top_stats stream_net_stats proc_stats" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    mtg)
      COMPREPLY=($(compgen -W "help oracle_json rules card_json card" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    multiple_choice)
      COMPREPLY=($(compgen -W "help multiple_choice" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    net)
      COMPREPLY=($(compgen -W "help dataurl rtt ip4 ip4gw serve dump_url wiki wifi_device wifi_name ssh_fingerprint" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    notes)
      COMPREPLY=($(compgen -W "help note list sync todo undo perl api_list_notes backup api_empty_notes api_list_todos print_todo_categories api_git api_clone api_fsck nw window api_find api_quick_title log api_match_files ls hist api_drop_note gc api_update_note api_edit_note api_perl_preview" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    omdb)
      COMPREPLY=($(compgen -W "help set_key register_key get_key query guess_title" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    path)
      COMPREPLY=($(compgen -W "help expand push pop" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    pkg)
      COMPREPLY=($(compgen -W "help install_or_skip" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    python)
      COMPREPLY=($(compgen -W "help venv ipynb detect_python latest_python func black" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    quick)
      COMPREPLY=($(compgen -W "help rebuild q" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    rust)
      COMPREPLY=($(compgen -W "help rustup install_goodies" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    screen)
      COMPREPLY=($(compgen -W "help session window rename home reset_dirname" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    strings)
      COMPREPLY=($(compgen -W "help urlencode strip_control repeat join sgrep strip_prefix" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    time)
      COMPREPLY=($(compgen -W "help file_mtime file_age" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    util)
      COMPREPLY=($(compgen -W "help sud reload markdown human_size install_heroku_cli bazel jup wait_for_file forex trim" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    xterm_colors)
      COMPREPLY=($(compgen -W "help channel_step greyscale_step rgb_to_xterm hue_diff brightness contrast xterm_to_rgb xterm_to_fg xterm_to_bg tfmt color shades colors" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    esac
    ;;
  *)
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"
    case "${COMP_WORDS[1]}" in
    ascii_art)
      case "${COMP_WORDS[2]}" in
      print_speech_bubble)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      erase_lines)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      cursor_position)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      cursor_row)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      print_bmo)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      print_pedro)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      scroll_output_pedro)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      select_visual)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    bash)
      case "${COMP_WORDS[2]}" in
      get_bash_functions)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    browser)
      case "${COMP_WORDS[2]}" in
      gdocs_id)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      sheets_dl_link)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      chrome_path)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      downloads_path)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      dl)
        # browser_dl URL
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    crypt)
      case "${COMP_WORDS[2]}" in
      encrypt_symmetric)
        # encrypt_symmetric FILE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      decrypt_symmetric)
        # decrypt_symmetric FILE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      gen_github_keypair)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      package)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      payloadify)
        # payloadify FILE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      downloadify)
        # downloadify FILE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      hash)
        # crypt_hash ALGO [INPUT]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    fedora)
      case "${COMP_WORDS[2]}" in
      setup)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      dnf_install_or_skip)
        # dnf_install_or_skip package1 package2 ...
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(1)
        local positional_types=(DEFAULT DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    find)
      case "${COMP_WORDS[2]}" in
      f)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      fcc)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      fgo)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      fjava)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      faidl)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      fd)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    git)
      case "${COMP_WORDS[2]}" in
      mkproject)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      git-ssh-init)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    go)
      case "${COMP_WORDS[2]}" in
      pkg_do)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    hg)
      case "${COMP_WORDS[2]}" in
      root)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    install)
      case "${COMP_WORDS[2]}" in
      reinstall_file)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      file)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      uninstall_file)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    keys)
      case "${COMP_WORDS[2]}" in
      git)
        # keys_git [ARGS ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      path)
        # keys_path [-f] KEY
        local switch_names=()
        local keyword_names=(-f)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -f)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      var)
        # keys_var KEY
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    mac)
      case "${COMP_WORDS[2]}" in
      setup)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      brew)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      get_user_shell)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      brew_bash_path)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      switch_to_bash)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      icloud)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      icloud_evict)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      brew_install_or_skip)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      install_miniconda)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      install_devtools)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      kill_defender)
        # mac_kill_defender
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      suppress_defender)
        # mac_suppress_defender
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      kill_crashplan)
        # mac_kill_crashplan
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    media)
      case "${COMP_WORDS[2]}" in
      yt-dl)
        # yt-dl [OPTIONS ...] URL
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(DEFAULT DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    monitor)
      case "${COMP_WORDS[2]}" in
      stream_load_stats)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      load_hist)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      latest_load_stats)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      write_load_stats)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      stream_top_stats)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      stream_net_stats)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      proc_stats)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    mtg)
      case "${COMP_WORDS[2]}" in
      oracle_json)
        # mtg_oracle_json
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      rules)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      card_json)
        # mtg_card_json NAME
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      card)
        # mtg_card NAME
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    multiple_choice)
      case "${COMP_WORDS[2]}" in
      multiple_choice)
        # multiple_choice [-n|-L] [-i INPUT] [-p PAGE] [-m MSG] [-a ALPHABET] [-I CONTROLS] [-A CONTROL_ALPHABET]
        local switch_names=(-n -L)
        local keyword_names=(-i -p -m -a -I -A)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -n)
              state="EXPECT_ARG"
              ;;
            -i)
              state="EXPECT_VALUE_STRING"
              ;;
            -p)
              state="EXPECT_VALUE_STRING"
              ;;
            -m)
              state="EXPECT_VALUE_STRING"
              ;;
            -a)
              state="EXPECT_VALUE_STRING"
              ;;
            -I)
              state="EXPECT_VALUE_STRING"
              ;;
            -A)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    net)
      case "${COMP_WORDS[2]}" in
      dataurl)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      rtt)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ip4)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ip4gw)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      serve)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      dump_url)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      wiki)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      wifi_device)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      wifi_name)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ssh_fingerprint)
        # net_ssh_fingerprint HOST
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    notes)
      case "${COMP_WORDS[2]}" in
      note)
        # notes_note [NOTE]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      list)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      sync)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      todo)
        # notes_todo [TERM ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      undo)
        # notes_undo [-f]
        local switch_names=(-f)
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -f)
              state="EXPECT_ARG"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      perl)
        # notes_perl PROG [TERM ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(1)
        local positional_types=(DEFAULT DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_list_notes)
        # notes_api_match_files [-f] [-a] [TERM ...]
        local switch_names=(-f)
        local keyword_names=(-a)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -f)
              state="EXPECT_ARG"
              ;;
            -a)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      backup)
        # notes_backup
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_empty_notes)
        # notes_api_edit_notes
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_list_todos)
        # notes_api_list_todos [CONTEXT] [TERM ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(1)
        local positional_types=(DEFAULT DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      print_todo_categories)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_git)
        # notes_api_git [ARGS ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_clone)
        # notes_api_clone
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_fsck)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      nw)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      window)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_find)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_quick_title)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      log)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_match_files)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ls)
        # notes_list [TERM ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      hist)
        # notes_hist [N]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_drop_note)
        # notes_api_drop_note NOTE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      gc)
        # notes_gc
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_update_note)
        # notes_api_update_note RELPATH CONTENTS
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_edit_note)
        # notes_api_edit_note PATH [LINE]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_perl_preview)
        # notes_api_perl_preview PROG [TERM ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(1)
        local positional_types=(DEFAULT DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    omdb)
      case "${COMP_WORDS[2]}" in
      set_key)
        # omdb_set_key KEY
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      register_key)
        # omdb_register_key
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      get_key)
        # omdb_get_key
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      query)
        # omdb_query [-f] [QUERY ...]
        local switch_names=()
        local keyword_names=(-f)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -f)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      guess_title)
        # omdb_guess_title FILE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    path)
      case "${COMP_WORDS[2]}" in
      expand)
        # path_expand PATH
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      push)
        # path_push DIRECTORY
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      pop)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    pkg)
      case "${COMP_WORDS[2]}" in
      install_or_skip)
        # pkg_install_or_skip [PACKAGE...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    python)
      case "${COMP_WORDS[2]}" in
      venv)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ipynb)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      detect_python)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      latest_python)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      func)
        # python_func -f|--function FUNCTION -p|--path PATH [-J|--json_output] [--clean] [--debug] [--] [ARGS...]
        local switch_names=(-J --json_output --clean --debug)
        local keyword_names=(-f --function -p --path --)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -f)
              state="EXPECT_VALUE_STRING"
              ;;
            -p)
              state="EXPECT_VALUE_FILE"
              ;;
            -J)
              state="EXPECT_ARG"
              ;;
            --clean)
              state="EXPECT_ARG"
              ;;
            --debug)
              state="EXPECT_ARG"
              ;;
            --)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      black)
        # python_black [FILES...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    quick)
      case "${COMP_WORDS[2]}" in
      rebuild)
        # quick_rebuild [--src-path PATH] [--skip-extra-paths]
        local switch_names=(--skip-extra-paths)
        local keyword_names=(--src-path)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            --src-path)
              state="EXPECT_VALUE_FILE"
              ;;
            --skip-extra-paths)
              state="EXPECT_ARG"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      q)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    rust)
      case "${COMP_WORDS[2]}" in
      rustup)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      install_goodies)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    screen)
      case "${COMP_WORDS[2]}" in
      session)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      window)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      rename)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      home)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      reset_dirname)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    strings)
      case "${COMP_WORDS[2]}" in
      urlencode)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      strip_control)
        # strip_control
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      repeat)
        # repeat STRING N
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DEFAULT DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      join)
        # strings_join DELIMITER [STRING ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(1)
        local positional_types=(DEFAULT DEFAULT)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      sgrep)
        # sgrep [-C NUM]
        local switch_names=()
        local keyword_names=(-C)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -C)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      strip_prefix)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    time)
      case "${COMP_WORDS[2]}" in
      file_mtime)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      file_age)
        # file_age [-s] PATH
        local switch_names=()
        local keyword_names=(-s)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -s)
              state="EXPECT_VALUE_FILE"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    util)
      case "${COMP_WORDS[2]}" in
      sud)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      reload)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      markdown)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      human_size)
        # human_size [-b|-bb|-S|-h|-hh] SIZE
        local switch_names=()
        local keyword_names=(-b -bb -S -h -hh)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -b)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      install_heroku_cli)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      bazel)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      jup)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      wait_for_file)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      forex)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      trim)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    xterm_colors)
      case "${COMP_WORDS[2]}" in
      channel_step)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      greyscale_step)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      rgb_to_xterm)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      hue_diff)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      brightness)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      contrast)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      xterm_to_rgb)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      xterm_to_fg)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      xterm_to_bg)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      tfmt)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      color)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      shades)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      colors)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    esac
    ;;
  esac
}

complete -F __q_compgen q

fi
