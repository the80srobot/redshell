# This file is generated by quick.py. Do not edit.
# Run q quick rebuild to regenerate.

if [[ -z "${_REDSHELL_GEN_QUICK}" || -n "${_REDSHELL_RELOAD}" ]]; then
_REDSHELL_GEN_QUICK=1
function __q() {
  if [ "$#" -eq 0 ]; then
    __q_help
    return 0
  fi
  case "$1" in
  help|-h|--help|?)
    shift
    __q_help "$@"
    ;;
  dump)
    shift
    __q_dump "$@"
    ;;
  ascii_art)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "ascii_art" "$@"
      ;;
    print_speech_bubble)
      shift
      print_speech_bubble "$@"
      ;;
    erase_lines)
      shift
      erase_lines "$@"
      ;;
    cursor_position)
      shift
      cursor_position "$@"
      ;;
    cursor_row)
      shift
      cursor_row "$@"
      ;;
    print_bmo)
      shift
      print_bmo "$@"
      ;;
    print_pedro)
      shift
      print_pedro "$@"
      ;;
    scroll_output_pedro)
      shift
      scroll_output_pedro "$@"
      ;;
    select_visual)
      shift
      select_visual "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module ascii_art has no function $1"
      fi
      __q_help ascii_art
      return 1
      ;;
    esac
    ;;
  bash)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "bash" "$@"
      ;;
    get_bash_functions)
      shift
      get_bash_functions "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module bash has no function $1"
      fi
      __q_help bash
      return 1
      ;;
    esac
    ;;
  browser)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "browser" "$@"
      ;;
    gdocs_id)
      shift
      gdocs_id "$@"
      ;;
    sheets_dl_link)
      shift
      sheets_dl_link "$@"
      ;;
    chrome_path)
      shift
      chrome_path "$@"
      ;;
    downloads_path)
      shift
      downloads_path "$@"
      ;;
    browser_dl|dl)
      shift
      browser_dl "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module browser has no function $1"
      fi
      __q_help browser
      return 1
      ;;
    esac
    ;;
  crypt)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "crypt" "$@"
      ;;
    encrypt_symmetric)
      shift
      encrypt_symmetric "$@"
      ;;
    decrypt_symmetric)
      shift
      decrypt_symmetric "$@"
      ;;
    gen_github_keypair)
      shift
      gen_github_keypair "$@"
      ;;
    package)
      shift
      package "$@"
      ;;
    payloadify)
      shift
      payloadify "$@"
      ;;
    downloadify)
      shift
      downloadify "$@"
      ;;
    crypt_hash|hash)
      shift
      crypt_hash "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module crypt has no function $1"
      fi
      __q_help crypt
      return 1
      ;;
    esac
    ;;
  debian)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "debian" "$@"
      ;;
    debian_setup|setup)
      shift
      debian_setup "$@"
      ;;
    debian_install_or_skip|install_or_skip)
      shift
      debian_install_or_skip "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module debian has no function $1"
      fi
      __q_help debian
      return 1
      ;;
    esac
    ;;
  fedora)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "fedora" "$@"
      ;;
    fedora_setup|setup)
      shift
      fedora_setup "$@"
      ;;
    dnf_install_or_skip)
      shift
      dnf_install_or_skip "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module fedora has no function $1"
      fi
      __q_help fedora
      return 1
      ;;
    esac
    ;;
  file)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "file" "$@"
      ;;
    file_mktemp|mktemp)
      shift
      file_mktemp "$@"
      ;;
    file_mtime|mtime)
      shift
      file_mtime "$@"
      ;;
    file_age|age)
      shift
      file_age "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module file has no function $1"
      fi
      __q_help file
      return 1
      ;;
    esac
    ;;
  find)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "find" "$@"
      ;;
    f)
      shift
      f "$@"
      ;;
    fcc)
      shift
      fcc "$@"
      ;;
    fgo)
      shift
      fgo "$@"
      ;;
    fjava)
      shift
      fjava "$@"
      ;;
    faidl)
      shift
      faidl "$@"
      ;;
    fd)
      shift
      fd "$@"
      ;;
    find_replace|replace)
      shift
      find_replace "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module find has no function $1"
      fi
      __q_help find
      return 1
      ;;
    esac
    ;;
  git)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "git" "$@"
      ;;
    mkproject)
      shift
      mkproject "$@"
      ;;
    git_ssh_init|ssh_init)
      shift
      git_ssh_init "$@"
      ;;
    git_changed_lines|changed_lines)
      shift
      git_changed_lines "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module git has no function $1"
      fi
      __q_help git
      return 1
      ;;
    esac
    ;;
  go)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "go" "$@"
      ;;
    go_pkg_do|pkg_do)
      shift
      go_pkg_do "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module go has no function $1"
      fi
      __q_help go
      return 1
      ;;
    esac
    ;;
  grepo)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "grepo" "$@"
      ;;
    grepo_checkout|checkout)
      shift
      grepo_checkout "$@"
      ;;
    grepo_lfs_pull|lfs_pull)
      shift
      grepo_lfs_pull "$@"
      ;;
    grepo_remove_branch|remove_branch)
      shift
      grepo_remove_branch "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module grepo has no function $1"
      fi
      __q_help grepo
      return 1
      ;;
    esac
    ;;
  hg)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "hg" "$@"
      ;;
    hg_root|root)
      shift
      hg_root "$@"
      ;;
    hg_repo_name|repo_name)
      shift
      hg_repo_name "$@"
      ;;
    hg_branch_name|branch_name)
      shift
      hg_branch_name "$@"
      ;;
    hg_ps1_widget|ps1_widget)
      shift
      hg_ps1_widget "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module hg has no function $1"
      fi
      __q_help hg
      return 1
      ;;
    esac
    ;;
  init)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "init" "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module init has no function $1"
      fi
      __q_help init
      return 1
      ;;
    esac
    ;;
  install)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "install" "$@"
      ;;
    install_file|file)
      shift
      install_file "$@"
      ;;
    reinstall_file)
      shift
      reinstall_file "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module install has no function $1"
      fi
      __q_help install
      return 1
      ;;
    esac
    ;;
  keys)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "keys" "$@"
      ;;
    keys_git|git)
      shift
      keys_git "$@"
      ;;
    keys_path|path)
      shift
      keys_path "$@"
      ;;
    keys_var|var)
      shift
      keys_var "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module keys has no function $1"
      fi
      __q_help keys
      return 1
      ;;
    esac
    ;;
  mac)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "mac" "$@"
      ;;
    mac_setup|setup)
      shift
      mac_setup "$@"
      ;;
    brew)
      shift
      brew "$@"
      ;;
    mac_get_user_shell|get_user_shell)
      shift
      mac_get_user_shell "$@"
      ;;
    mac_brew_bash_path|brew_bash_path)
      shift
      mac_brew_bash_path "$@"
      ;;
    mac_switch_to_bash|switch_to_bash)
      shift
      mac_switch_to_bash "$@"
      ;;
    icloud)
      shift
      icloud "$@"
      ;;
    icloud_evict)
      shift
      icloud_evict "$@"
      ;;
    brew_install_or_skip)
      shift
      brew_install_or_skip "$@"
      ;;
    mac_install_miniconda|install_miniconda)
      shift
      mac_install_miniconda "$@"
      ;;
    mac_install_devtools|install_devtools)
      shift
      mac_install_devtools "$@"
      ;;
    mac_kill_defender|kill_defender)
      shift
      mac_kill_defender "$@"
      ;;
    mac_suppress_defender|suppress_defender)
      shift
      mac_suppress_defender "$@"
      ;;
    mac_kill_crashplan|kill_crashplan)
      shift
      mac_kill_crashplan "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module mac has no function $1"
      fi
      __q_help mac
      return 1
      ;;
    esac
    ;;
  media)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "media" "$@"
      ;;
    yt-dl)
      shift
      yt-dl "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module media has no function $1"
      fi
      __q_help media
      return 1
      ;;
    esac
    ;;
  monitor)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "monitor" "$@"
      ;;
    stream_load_stats)
      shift
      stream_load_stats "$@"
      ;;
    load_hist)
      shift
      load_hist "$@"
      ;;
    latest_load_stats)
      shift
      latest_load_stats "$@"
      ;;
    write_load_stats)
      shift
      write_load_stats "$@"
      ;;
    stream_top_stats)
      shift
      stream_top_stats "$@"
      ;;
    stream_net_stats)
      shift
      stream_net_stats "$@"
      ;;
    proc_stats)
      shift
      proc_stats "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module monitor has no function $1"
      fi
      __q_help monitor
      return 1
      ;;
    esac
    ;;
  mtg)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "mtg" "$@"
      ;;
    mtg_oracle_json|oracle_json)
      shift
      mtg_oracle_json "$@"
      ;;
    mtg_rules|rules)
      shift
      mtg_rules "$@"
      ;;
    mtg_card_json|card_json)
      shift
      mtg_card_json "$@"
      ;;
    mtg_card|card)
      shift
      mtg_card "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module mtg has no function $1"
      fi
      __q_help mtg
      return 1
      ;;
    esac
    ;;
  multiple_choice)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "multiple_choice" "$@"
      ;;
    multiple_choice)
      shift
      multiple_choice "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module multiple_choice has no function $1"
      fi
      __q_help multiple_choice
      return 1
      ;;
    esac
    ;;
  net)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "net" "$@"
      ;;
    net_online|online)
      shift
      net_online "$@"
      ;;
    net_health|health)
      shift
      net_health "$@"
      ;;
    net_ssh_fingerprint|ssh_fingerprint)
      shift
      net_ssh_fingerprint "$@"
      ;;
    net_dump_cert|dump_cert)
      shift
      net_dump_cert "$@"
      ;;
    net_ccurl|ccurl)
      shift
      net_ccurl "$@"
      ;;
    net_dataurl|dataurl)
      shift
      net_dataurl "$@"
      ;;
    net_undataurl|undataurl)
      shift
      net_undataurl "$@"
      ;;
    net_rtt|rtt)
      shift
      net_rtt "$@"
      ;;
    net_ip4|ip4)
      shift
      net_ip4 "$@"
      ;;
    net_ip4gw|ip4gw)
      shift
      net_ip4gw "$@"
      ;;
    net_serve|serve)
      shift
      net_serve "$@"
      ;;
    dump_url)
      shift
      dump_url "$@"
      ;;
    wiki)
      shift
      wiki "$@"
      ;;
    wifi_device)
      shift
      wifi_device "$@"
      ;;
    net_wifi_name|wifi_name)
      shift
      net_wifi_name "$@"
      ;;
    net_ssh_fingerprint|ssh_fingerprint)
      shift
      net_ssh_fingerprint "$@"
      ;;
    net_ssh_aliases|ssh_aliases)
      shift
      net_ssh_aliases "$@"
      ;;
    net_ssh_fqdn|ssh_fqdn)
      shift
      net_ssh_fqdn "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module net has no function $1"
      fi
      __q_help net
      return 1
      ;;
    esac
    ;;
  news)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "news" "$@"
      ;;
    news_all|all)
      shift
      news_all "$@"
      ;;
    news_stocks|stocks)
      shift
      news_stocks "$@"
      ;;
    news_weather|weather)
      shift
      news_weather "$@"
      ;;
    news_brutalist_report_source|brutalist_report_source)
      shift
      news_brutalist_report_source "$@"
      ;;
    news_nytimes|nytimes)
      shift
      news_nytimes "$@"
      ;;
    news_npr|npr)
      shift
      news_npr "$@"
      ;;
    news_pbs|pbs)
      shift
      news_pbs "$@"
      ;;
    news_register|register)
      shift
      news_register "$@"
      ;;
    news_cnbc|cnbc)
      shift
      news_cnbc "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module news has no function $1"
      fi
      __q_help news
      return 1
      ;;
    esac
    ;;
  notes)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "notes" "$@"
      ;;
    notes_note|note)
      shift
      notes_note "$@"
      ;;
    notes_list|list)
      shift
      notes_list "$@"
      ;;
    notes_sync|sync)
      shift
      notes_sync "$@"
      ;;
    notes_todo|todo)
      shift
      notes_todo "$@"
      ;;
    notes_undo|undo)
      shift
      notes_undo "$@"
      ;;
    notes_perl|perl)
      shift
      notes_perl "$@"
      ;;
    notes_api_list_notes|api_list_notes)
      shift
      notes_api_list_notes "$@"
      ;;
    notes_backup|backup)
      shift
      notes_backup "$@"
      ;;
    notes_api_empty_notes|api_empty_notes)
      shift
      notes_api_empty_notes "$@"
      ;;
    notes_api_list_todos|api_list_todos)
      shift
      notes_api_list_todos "$@"
      ;;
    print_todo_categories)
      shift
      print_todo_categories "$@"
      ;;
    notes_api_git|api_git)
      shift
      notes_api_git "$@"
      ;;
    notes_api_pushd|api_pushd)
      shift
      notes_api_pushd "$@"
      ;;
    notes_api_clone|api_clone)
      shift
      notes_api_clone "$@"
      ;;
    notes_api_fsck|api_fsck)
      shift
      notes_api_fsck "$@"
      ;;
    nw)
      shift
      nw "$@"
      ;;
    notes_window|window)
      shift
      notes_window "$@"
      ;;
    notes_api_find|api_find)
      shift
      notes_api_find "$@"
      ;;
    notes_api_quick_title|api_quick_title)
      shift
      notes_api_quick_title "$@"
      ;;
    notes_log|log)
      shift
      notes_log "$@"
      ;;
    notes_api_match_files|api_match_files)
      shift
      notes_api_match_files "$@"
      ;;
    notes_ls|ls)
      shift
      notes_ls "$@"
      ;;
    notes_hist|hist)
      shift
      notes_hist "$@"
      ;;
    notes_api_drop_note|api_drop_note)
      shift
      notes_api_drop_note "$@"
      ;;
    notes_gc|gc)
      shift
      notes_gc "$@"
      ;;
    notes_api_update_note|api_update_note)
      shift
      notes_api_update_note "$@"
      ;;
    notes_api_edit_note|api_edit_note)
      shift
      notes_api_edit_note "$@"
      ;;
    notes_api_perl_preview|api_perl_preview)
      shift
      notes_api_perl_preview "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module notes has no function $1"
      fi
      __q_help notes
      return 1
      ;;
    esac
    ;;
  omdb)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "omdb" "$@"
      ;;
    omdb_set_key|set_key)
      shift
      omdb_set_key "$@"
      ;;
    omdb_register_key|register_key)
      shift
      omdb_register_key "$@"
      ;;
    omdb_get_key|get_key)
      shift
      omdb_get_key "$@"
      ;;
    omdb_query|query)
      shift
      omdb_query "$@"
      ;;
    omdb_guess_title|guess_title)
      shift
      omdb_guess_title "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module omdb has no function $1"
      fi
      __q_help omdb
      return 1
      ;;
    esac
    ;;
  path)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "path" "$@"
      ;;
    path_expand|expand)
      shift
      path_expand "$@"
      ;;
    path_push|push)
      shift
      path_push "$@"
      ;;
    path_pop|pop)
      shift
      path_pop "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module path has no function $1"
      fi
      __q_help path
      return 1
      ;;
    esac
    ;;
  pkg)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "pkg" "$@"
      ;;
    pkg_install_or_skip|install_or_skip)
      shift
      pkg_install_or_skip "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module pkg has no function $1"
      fi
      __q_help pkg
      return 1
      ;;
    esac
    ;;
  python)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "python" "$@"
      ;;
    python_venv|venv)
      shift
      python_venv "$@"
      ;;
    python_pip_run|pip_run)
      shift
      python_pip_run "$@"
      ;;
    python_ipynb|ipynb)
      shift
      python_ipynb "$@"
      ;;
    python_detect|detect)
      shift
      python_detect "$@"
      ;;
    python_latest|latest)
      shift
      python_latest "$@"
      ;;
    python_func|func)
      shift
      python_func "$@"
      ;;
    python_black|black)
      shift
      python_black "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module python has no function $1"
      fi
      __q_help python
      return 1
      ;;
    esac
    ;;
  quick)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "quick" "$@"
      ;;
    quick_rebuild|rebuild)
      shift
      quick_rebuild "$@"
      ;;
    q)
      shift
      q "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module quick has no function $1"
      fi
      __q_help quick
      return 1
      ;;
    esac
    ;;
  rust)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "rust" "$@"
      ;;
    rustup)
      shift
      rustup "$@"
      ;;
    rust_install_goodies|install_goodies)
      shift
      rust_install_goodies "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module rust has no function $1"
      fi
      __q_help rust
      return 1
      ;;
    esac
    ;;
  screen)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "screen" "$@"
      ;;
    screen_session|session)
      shift
      screen_session "$@"
      ;;
    screen_window|window)
      shift
      screen_window "$@"
      ;;
    screen_rename|rename)
      shift
      screen_rename "$@"
      ;;
    screen_home|home)
      shift
      screen_home "$@"
      ;;
    screen_reset_dirname|reset_dirname)
      shift
      screen_reset_dirname "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module screen has no function $1"
      fi
      __q_help screen
      return 1
      ;;
    esac
    ;;
  strings)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "strings" "$@"
      ;;
    strings_urlencode|urlencode)
      shift
      strings_urlencode "$@"
      ;;
    strings_strip_control|strip_control)
      shift
      strings_strip_control "$@"
      ;;
    strings_repeat|repeat)
      shift
      strings_repeat "$@"
      ;;
    strings_join|join)
      shift
      strings_join "$@"
      ;;
    strings_sgrep|sgrep)
      shift
      strings_sgrep "$@"
      ;;
    strings_strip_prefix|strip_prefix)
      shift
      strings_strip_prefix "$@"
      ;;
    strings_trim|trim)
      shift
      strings_trim "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module strings has no function $1"
      fi
      __q_help strings
      return 1
      ;;
    esac
    ;;
  time)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "time" "$@"
      ;;
    time_zones|zones)
      shift
      time_zones "$@"
      ;;
    time_get_tz|get_tz)
      shift
      time_get_tz "$@"
      ;;
    time_local|local)
      shift
      time_local "$@"
      ;;
    time_utc|utc)
      shift
      time_utc "$@"
      ;;
    time_in|in)
      shift
      time_in "$@"
      ;;
    time_tz_diff|tz_diff)
      shift
      time_tz_diff "$@"
      ;;
    time_ts|ts)
      shift
      time_ts "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module time has no function $1"
      fi
      __q_help time
      return 1
      ;;
    esac
    ;;
  transit)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "transit" "$@"
      ;;
    transit_sbb|sbb)
      shift
      transit_sbb "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module transit has no function $1"
      fi
      __q_help transit
      return 1
      ;;
    esac
    ;;
  util)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "util" "$@"
      ;;
    sud)
      shift
      sud "$@"
      ;;
    reload)
      shift
      reload "$@"
      ;;
    util_markdown|markdown)
      shift
      util_markdown "$@"
      ;;
    human_size)
      shift
      human_size "$@"
      ;;
    install_heroku_cli)
      shift
      install_heroku_cli "$@"
      ;;
    bazel)
      shift
      bazel "$@"
      ;;
    jup)
      shift
      jup "$@"
      ;;
    wait_for_file)
      shift
      wait_for_file "$@"
      ;;
    util_forex|forex)
      shift
      util_forex "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module util has no function $1"
      fi
      __q_help util
      return 1
      ;;
    esac
    ;;
  xterm_colors)
    shift
    case "$1" in
    help|-h|--help|?)
      shift
      __q_help "xterm_colors" "$@"
      ;;
    channel_step)
      shift
      channel_step "$@"
      ;;
    greyscale_step)
      shift
      greyscale_step "$@"
      ;;
    rgb_to_xterm)
      shift
      rgb_to_xterm "$@"
      ;;
    hue_diff)
      shift
      hue_diff "$@"
      ;;
    brightness)
      shift
      brightness "$@"
      ;;
    contrast)
      shift
      contrast "$@"
      ;;
    xterm_to_rgb)
      shift
      xterm_to_rgb "$@"
      ;;
    xterm_to_fg)
      shift
      xterm_to_fg "$@"
      ;;
    xterm_to_bg)
      shift
      xterm_to_bg "$@"
      ;;
    tfmt)
      shift
      tfmt "$@"
      ;;
    color)
      shift
      color "$@"
      ;;
    shades)
      shift
      shades "$@"
      ;;
    colors)
      shift
      colors "$@"
      ;;
    *)
      if [ -n "$1" ]; then
        echo "Module xterm_colors has no function $1"
      fi
      __q_help xterm_colors
      return 1
      ;;
    esac
    ;;
  *)
    echo "Unknown module $1"
    return 1
    ;;
  esac
}

function __q_help() {
  if [ "$#" -eq 0 ]; then
    echo "q - redshell function registry"
    echo "Usage: q [-h|--help] MODULE FUNCTION [ARG...]"
    echo "Run q --help MODULE for more information on a module."
    echo
    echo "Available modules:"
    tput bold
    echo -n '  ascii_art'
    tput sgr0
    echo '         Assorted ascii art, screen drawing and speech bubbles.'
    tput bold
    echo -n '  bash'
    tput sgr0
    echo '              Parse bash files and automate bash scripting.'
    tput bold
    echo -n '  browser'
    tput sgr0
    echo '           Browser automation, downloads, link generators.'
    tput bold
    echo -n '  crypt'
    tput sgr0
    echo '             Encrypt/decrypt, signing, keypairs. SSH and GPG helpers.'
    tput bold
    echo -n '  debian'
    tput sgr0
    echo '            Debian setup and package management.'
    tput bold
    echo -n '  fedora'
    tput sgr0
    echo '            Fedora setup and package management.'
    tput bold
    echo -n '  file'
    tput sgr0
    echo '              File helpers.'
    tput bold
    echo -n '  find'
    tput sgr0
    echo '              Shorthands for find and grep.'
    tput bold
    echo -n '  git'
    tput sgr0
    echo '               Automate git and github operations.'
    tput bold
    echo -n '  go'
    tput sgr0
    echo '                Helpers for dealing with Go packages.'
    tput bold
    echo -n '  grepo'
    tput sgr0
    echo '             Automate grepo (aosp repo tool) operations.'
    tput bold
    echo -n '  hg'
    tput sgr0
    echo '                Mercurial helpers.'
    tput bold
    echo -n '  install'
    tput sgr0
    echo '           Install a file into another file, optionally with a keyword.'
    tput bold
    echo -n '  keys'
    tput sgr0
    echo '              Key management utils using pass and gpg.'
    tput bold
    echo -n '  mac'
    tput sgr0
    echo '               Mac setup, package management and various helpers.'
    tput bold
    echo -n '  media'
    tput sgr0
    echo '             Functions for working with media, ffmpeg, youtube, etc.'
    tput bold
    echo -n '  monitor'
    tput sgr0
    echo '           System load monitoring and logging.'
    tput bold
    echo -n '  mtg'
    tput sgr0
    echo '               Stuff for Magic: The Gathering.'
    tput bold
    echo -n '  multiple_choice'
    tput sgr0
    echo '   Interactive multiple choice prompts.'
    tput bold
    echo -n '  net'
    tput sgr0
    echo '               Network and wifi helpers, netcat wrappers, etc.'
    tput bold
    echo -n '  news'
    tput sgr0
    echo '              News and weather.'
    tput bold
    echo -n '  notes'
    tput sgr0
    echo '             Note management based on git and markdown.'
    tput bold
    echo -n '  omdb'
    tput sgr0
    echo '              OMDB (Open Movie Database) helpers for bash.'
    tput bold
    echo -n '  path'
    tput sgr0
    echo '              UNIX style path helpers.'
    tput bold
    echo -n '  pkg'
    tput sgr0
    echo '               Cross-platform package management.'
    tput bold
    echo -n '  python'
    tput sgr0
    echo '            Python env management, python-shell FFI and Jupyter.'
    tput bold
    echo -n '  quick'
    tput sgr0
    echo '             Redshell function help, switch and autocomplete.'
    tput bold
    echo -n '  rust'
    tput sgr0
    echo '              Manage rust toolchain and environment.'
    tput bold
    echo -n '  screen'
    tput sgr0
    echo '            UNIX style path helpers.'
    tput bold
    echo -n '  strings'
    tput sgr0
    echo '           String helpers for bash.'
    tput bold
    echo -n '  time'
    tput sgr0
    echo '              Time and date helpers.'
    tput bold
    echo -n '  transit'
    tput sgr0
    echo '           Transit helpers.'
    tput bold
    echo -n '  util'
    tput sgr0
    echo '              Catch-all utility functions that don'"'"'t fit anywhere else.'
    tput bold
    echo -n '  xterm_colors'
    tput sgr0
    echo '      Work with the xterm color space, convert to RGB, etc.'
    return 0
  fi
  if [ "$#" -eq 1 ]; then
    case "$1" in
    ascii_art)
      echo "Usage: q ascii_art FUNCTION [ARG...]"
      echo "Assorted ascii art, screen drawing and speech bubbles."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  print_speech_bubble'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  erase_lines'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  cursor_position'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  cursor_row'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  print_bmo'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  print_pedro'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  scroll_output_pedro'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  select_visual'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    bash)
      echo "Usage: q bash FUNCTION [ARG...]"
      echo "Parse bash files and automate bash scripting."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  get_bash_functions'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    browser)
      echo "Usage: q browser FUNCTION [ARG...]"
      echo "Browser automation, downloads, link generators."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  gdocs_id'
      echo -n ' URL'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Extracts a Google Docs ID from a URL.'
      tput bold
      echo -n '  sheets_dl_link'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Usage sheets_dl_link URL [FORMAT]'
      echo '    Generates a direct download link for a Google Docs spreadsheet.'
      echo '    FORMAT is optional and defaults to "csv".'
      tput bold
      echo -n '  chrome_path'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Returns the path to the Chrome executable.'
      tput bold
      echo -n '  downloads_path'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Returns the path to the Downloads folder.'
      tput bold
      echo -n '  dl'
      echo -n ' URL'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Downloads a URL with the browser and returns the path to the downloaded file.'
      echo '    This is finnicky and relies on the browser downloading to the default'
      echo '    Downloads folder. If multiple new files are created around the same time, this'
      echo '    might behave in unpredictable ways. You'"'"'ve been warned.'
      ;;
    crypt)
      echo "Usage: q crypt FUNCTION [ARG...]"
      echo "Encrypt/decrypt, signing, keypairs. SSH and GPG helpers."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  encrypt_symmetric'
      tput setaf 9
      echo -n ' FILE'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  decrypt_symmetric'
      tput setaf 9
      echo -n ' FILE'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  gen_github_keypair'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  package'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  payloadify'
      tput setaf 9
      echo -n ' FILE'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  downloadify'
      tput setaf 9
      echo -n ' FILE'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Encrypt a file and wrap it in a base64 self-unpacking shell script.'
      tput bold
      echo -n '  hash'
      echo -n ' ALGO'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' INPUT'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      echo "    alias h='q crypt hash'"
      tput sgr0
      echo '    Print a cryptographic hash of the input.'
      echo '    '
      echo '    If no INPUT is provided, read from stdin.'
      echo '    '
      echo '    Supported ALGO values: md5 or SHA version (1, 128, 224, 256, 512).'
      echo '    '
      echo '    hash 256 foo -> b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c'
      echo '    hash md5 foo -> d3b07384d113edec49eaa6238ad5ff00'
      ;;
    debian)
      echo "Usage: q debian FUNCTION [ARG...]"
      echo "Debian setup and package management."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  setup'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  install_or_skip'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    fedora)
      echo "Usage: q fedora FUNCTION [ARG...]"
      echo "Fedora setup and package management."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  setup'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  dnf_install_or_skip'
      echo -n ' package1'
      tput sgr0
      tput bold
      echo -n ' package2'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Install a package with dnf if it'"'"'s not already installed.'
      ;;
    file)
      echo "Usage: q file FUNCTION [ARG...]"
      echo "File helpers."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  mktemp'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' TITLE'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Cross-platform version of mktemp across BSD and GNU. Creates a temp file and'
      echo '    prints its path. If TITLE is supplied, it will be used as prefix or suffix.'
      tput bold
      echo -n '  mtime'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  age'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -s'
      tput sgr0
      tput bold
      tput setaf 9
      echo -n ' PATH'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    find)
      echo "Usage: q find FUNCTION [ARG...]"
      echo "Shorthands for find and grep."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  f'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Shorthand for find'
      tput bold
      echo -n '  fcc'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  fgo'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  fjava'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  faidl'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  fd'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  replace'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Usage find_replace [DIR] GLOB NEEDLE REPLACEMENT'
      ;;
    git)
      echo "Usage: q git FUNCTION [ARG...]"
      echo "Automate git and github operations."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  mkproject'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  ssh_init'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  changed_lines'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    go)
      echo "Usage: q go FUNCTION [ARG...]"
      echo "Helpers for dealing with Go packages."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  pkg_do'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    grepo)
      echo "Usage: q grepo FUNCTION [ARG...]"
      echo "Automate grepo (aosp repo tool) operations."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  checkout'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  lfs_pull'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  remove_branch'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    hg)
      echo "Usage: q hg FUNCTION [ARG...]"
      echo "Mercurial helpers."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  root'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Fast check for mercurial. (About 100 times faster than `hg root`.) Prints the'
      echo '    root directory of the repository if the current directory is in a repository.'
      echo '    Otherwise returns 1.'
      tput bold
      echo -n '  repo_name'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  branch_name'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  ps1_widget'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    init)
      echo "Usage: q init FUNCTION [ARG...]"
      echo "Initialization routines."
      echo
      echo "Available functions:"
      ;;
    install)
      echo "Usage: q install FUNCTION [ARG...]"
      echo "Install a file into another file, optionally with a keyword."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  file'
      echo -n ' -s|--sfile'
      tput sgr0
      tput bold
      tput setaf 9
      echo -n ' SFILE'
      tput sgr0
      tput bold
      echo -n ' -d|--dfile'
      tput sgr0
      tput bold
      tput setaf 9
      echo -n ' DFILE'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -c|--char'
      tput sgr0
      tput bold
      echo -n ' CHAR'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -k|--section'
      tput sgr0
      tput bold
      echo -n ' SECTION'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -d|--append'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' --uninstall'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Installs the contents of DFILE into SFILE, guarded by a comment at the first'
      echo '    and last line. Optional arguments CHAR and SECTION control what the commend'
      echo '    guard looks like. Default CHAR is '"'"'#'"'"' and default SECTION is '"'"'REDSHELL'"'"' for:'
      echo '    '
      echo '    # REDSHELL'
      echo '    ... contents'
      echo '    # /REDSHELL'
      echo '    '
      echo '    Subsequent calls to install_file remove the old contents before intalling the'
      echo '    new contents. New contents replace the old contents in-place.'
      echo '    '
      echo '    Pass --append to install the contents always at the end of the file, rather'
      echo '    than in-place. Pass --uninstall to only uninstall the file.'
      tput bold
      echo -n '  reinstall_file'
      tput setaf 9
      echo -n ' SFILE'
      tput sgr0
      tput bold
      tput setaf 9
      echo -n ' DFILE'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' CHAR'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' SECTION'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    This is a legacy form of install_file. It is kept for backwards compatibility.'
      echo '    '
      echo '    Installs the contents of DFILE into SFILE, guarded by a comment at the first'
      echo '    and last line. Optional arguments CHAR and SECTION control what the commend'
      echo '    guard looks like. Default CHAR is '"'"'#'"'"' and default SECTION is '"'"'REDSHELL'"'"' for:'
      echo '    '
      echo '    # REDSHELL'
      echo '    ... contents'
      echo '    # /REDSHELL'
      echo '    '
      echo '    Subsequent calls to reinstall_file remove the old contents before intalling'
      echo '    the new contents.'
      ;;
    keys)
      echo "Usage: q keys FUNCTION [ARG...]"
      echo "Key management utils using pass and gpg."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  git'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' ARGS'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Wraps git for use with the keys repository.'
      tput bold
      echo -n '  path'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -f'
      tput sgr0
      tput bold
      echo -n ' KEY'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Dumps the contents of the given key in a file and returns the path.'
      tput bold
      echo -n '  var'
      echo -n ' KEY'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Returns the conents of a given key in pass.'
      ;;
    mac)
      echo "Usage: q mac FUNCTION [ARG...]"
      echo "Mac setup, package management and various helpers."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  setup'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  brew'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  get_user_shell'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  brew_bash_path'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  switch_to_bash'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  icloud'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  icloud_evict'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  brew_install_or_skip'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  install_miniconda'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  install_devtools'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  kill_defender'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Kills Microsoft Defender in a way that tends to persist for an hour or so.'
      echo '    This is useful for working around bugs or surviving when they push and update'
      echo '    that breaks the OS.'
      echo '    '
      echo '    Use at your own risk, and only after discussing with your IT department. This'
      echo '    action is likely to be detected.'
      tput bold
      echo -n '  suppress_defender'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Keeps Microsoft Defender from restarting.'
      echo '    '
      echo '    Use at your own risk, and only after discussing with your IT department. This'
      echo '    action is likely to be detected.'
      tput bold
      echo -n '  kill_crashplan'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Stops CrashPlan from running. CrashPlan is a very poorly optimized backup'
      echo '    service. When you'"'"'re running IO intensive workloads, it can slow them down'
      echo '    massively and eat up 2-3 CPU cores.'
      ;;
    media)
      echo "Usage: q media FUNCTION [ARG...]"
      echo "Functions for working with media, ffmpeg, youtube, etc."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  yt-dl'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' OPTIONS'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' URL'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Wrapper areound yt-dlp. Automatically ensures dependencies are installed.'
      ;;
    monitor)
      echo "Usage: q monitor FUNCTION [ARG...]"
      echo "System load monitoring and logging."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  stream_load_stats'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  load_hist'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  latest_load_stats'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  write_load_stats'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  stream_top_stats'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  stream_net_stats'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  proc_stats'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Outputs:'
      echo '    1. CPU util'
      echo '    2. Physical RAM util'
      echo '    3. Total RSS'
      echo '    4. User time total'
      echo '    5. System time total'
      echo '    6. PID with the highest CPU util'
      echo '    7. Comm with the highest CPU util'
      echo '    8. CPU util of the proc with the highest CPU util'
      echo '    9. PID with the highest RSS'
      echo '    10. Comm with the highest RSS'
      echo '    11. RSS of the proc with the highest RSS'
      ;;
    mtg)
      echo "Usage: q mtg FUNCTION [ARG...]"
      echo "Stuff for Magic: The Gathering."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  oracle_json'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Fetch the latest oracle cards from Scryfall and return the path to the JSON'
      echo '    dump. The dump is cached for about two weeks.'
      tput bold
      echo -n '  rules'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  card_json'
      echo -n ' NAME'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Return the JSON object for the card with the given name. (Case sensitive.)'
      tput bold
      echo -n '  card'
      echo -n ' NAME'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Print the Magic: The Gathering card with the given name. (Case sensitive.)'
      ;;
    multiple_choice)
      echo "Usage: q multiple_choice FUNCTION [ARG...]"
      echo "Interactive multiple choice prompts."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  multiple_choice'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -n|-L'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -i'
      tput sgr0
      tput bold
      echo -n ' INPUT'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -p'
      tput sgr0
      tput bold
      echo -n ' PAGE'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -m'
      tput sgr0
      tput bold
      echo -n ' MSG'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -a'
      tput sgr0
      tput bold
      echo -n ' ALPHABET'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -I'
      tput sgr0
      tput bold
      echo -n ' CONTROLS'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -A'
      tput sgr0
      tput bold
      echo -n ' CONTROL_ALPHABET'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Display an interactive menu with multiple choices, and then print the selected option to stdout.'
      echo '    '
      echo '    -n: return the number of the selected option'
      echo '    -L: return the string of the selected option'
      echo '    -p: page number to show'
      echo '    -m: prompt message'
      echo '    -a: alphabet'
      echo '    -I: control options'
      echo '    -A: control alphabet'
      echo '    -i: input (options to pick from)'
      ;;
    net)
      echo "Usage: q net FUNCTION [ARG...]"
      echo "Network and wifi helpers, netcat wrappers, etc."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  online'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Check if you have a usable internet connection.'
      tput bold
      echo -n '  health'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  ssh_fingerprint'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  dump_cert'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  ccurl'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -M|--max-age'
      tput sgr0
      tput bold
      echo -n ' SECONDS'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -K|--key'
      tput sgr0
      tput bold
      echo -n ' KEY'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' --'
      tput sgr0
      tput bold
      echo -n ' CURL_ARGS'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Cached curl wrapper. Request parameters are converted to a key and used to'
      echo '    cache the response.'
      echo '    '
      echo '    Options:'
      echo '    -M, --max-age SECONDS  Maximum age of the cache in seconds. Default is 3600.'
      echo '    -K, --key KEY          Use the given key instead of the request parameters.'
      tput bold
      echo -n '  dataurl'
      tput setaf 9
      echo -n ' FILE'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Create a data URL from a file.'
      tput bold
      echo -n '  undataurl'
      echo
      tput sgr0
      tput setaf 6
      echo "    alias undataurl='q net undataurl'"
      tput sgr0
      echo '    Decode a dataurl from stdin onto stdout.'
      tput bold
      echo -n '  rtt'
      tput setaf 4
      echo -n ' HOST'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Average round-trip time to the specified host.'
      tput bold
      echo -n '  ip4'
      echo
      tput sgr0
      tput setaf 6
      echo "    alias ip4='q net ip4'"
      tput sgr0
      echo '    Print the non-localhost IPv4 addresses of this machine. One address per line.'
      tput bold
      echo -n '  ip4gw'
      echo
      tput sgr0
      tput setaf 6
      echo "    alias ip4gw='q net ip4gw'"
      tput sgr0
      echo '    Print the default gateway'"'"'s IP address.'
      tput bold
      echo -n '  serve'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  dump_url'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  wiki'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  wifi_device'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  wifi_name'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Print the name of the currently connected wifi network.'
      tput bold
      echo -n '  ssh_fingerprint'
      tput setaf 4
      echo -n ' HOST'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  ssh_aliases'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Prints the aliases and hostnames from the ssh config file.'
      tput bold
      echo -n '  ssh_fqdn'
      echo -n ' ALIAS'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Based on SSH config, looks up the full hostname of the given alias.'
      ;;
    news)
      echo "Usage: q news FUNCTION [ARG...]"
      echo "News and weather."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  all'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  stocks'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  weather'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  brutalist_report_source'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  nytimes'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  npr'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  pbs'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  register'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  cnbc'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    notes)
      echo "Usage: q notes FUNCTION [ARG...]"
      echo "Note management based on git and markdown."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  note'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' NOTE'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      echo "    alias n='q notes note'"
      tput sgr0
      echo '    Saves the provided note, intelligently placing it and generating a title. If'
      echo '    run with no arguments, instead opens vim and saves whatever is entered into'
      echo '    the file.'
      tput bold
      echo -n '  list'
      echo
      tput sgr0
      tput setaf 6
      echo "    alias nn='q notes list'"
      tput sgr0
      tput bold
      echo -n '  sync'
      echo
      tput sgr0
      tput setaf 6
      echo "    alias nsync='q notes sync'"
      tput sgr0
      tput bold
      echo -n '  todo'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' TERM'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      echo "    alias ntodo='q notes todo'"
      tput sgr0
      echo '    Shows an interactive listing of matching TODOs.'
      echo '    '
      echo '    Uses the following categories:'
      echo '    A -  - Asynchronous Comms'
      echo '    B -  - Bank'
      echo '    C -  - Calendar'
      echo '    E -  - Errand'
      echo '    H -  - Home'
      echo '    M -  - Meeting'
      echo '    L -  - Long Task'
      echo '    O -  - Office'
      echo '    R -  - Reading'
      echo '    S -  - Shopping'
      echo '    T -  - Telephone'
      echo '    W -  - Writing'
      echo '    X -  - Technical Task'
      echo '    Z -  - Misc Quick Task'
      echo '     - Inbox'
      tput bold
      echo -n '  undo'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -f'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      echo "    alias nundo='q notes undo'"
      tput sgr0
      echo '    Undoes the last note change. If the last change was to a local note, it will'
      echo '    refuse to undo it, unless -f is passed.'
      tput bold
      echo -n '  perl'
      echo -n ' PROG'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' TERM'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      echo "    alias nperl='q notes perl'"
      tput sgr0
      echo '    Applies the provided perl program to matching notes to generate replacements.'
      echo '    Then allows the user to select which replacements to save.'
      tput bold
      echo -n '  api_list_notes'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -f'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -a'
      tput sgr0
      tput bold
      echo -n ' TERM'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Outputs a list of notes files that match the given terms.'
      echo '    '
      echo '    Options:'
      echo '    -f: Only match files, not directories.'
      echo '    -a: Include archived files.'
      echo '    -w: Match whole words.'
      echo '    '
      echo '    Outputs:'
      echo '    1. relative path'
      echo '    2. mtime'
      echo '    3. age'
      echo '    4. line count'
      echo '    5. depth'
      echo '    6. absolute path'
      echo '    7. type (f or d)'
      echo '    8. title'
      echo '    9. location (g=git or l=local)'
      echo '    10. base path'
      echo '    11. Quick-TODO-aware title'
      echo '    12. Archived (A if archived - if not)'
      tput bold
      echo -n '  backup'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Backs up the notes repository to a timestamped tarball in the notes root.'
      tput bold
      echo -n '  api_empty_notes'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Lists empty notes.'
      tput bold
      echo -n '  api_list_todos'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' CONTEXT'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' TERM'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Lists TODOs matching the given context and terms.'
      echo '    '
      echo '    Outputs:'
      echo '    '
      echo '    1. Path'
      echo '    2. Line number'
      echo '    3. State (TODO or DONE)'
      echo '    4. Text of the TODO'
      echo '    5. Absolute path'
      echo '    6. File age'
      echo '    7. File mtime'
      echo '    8. Current state: TODO|DONE|LATER|OVERDUE|SOON'
      echo '    9. Earliest date (if any)'
      echo '    10. Due date (if any)'
      echo '    11. Context (one letter)'
      tput bold
      echo -n '  print_todo_categories'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  api_git'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' ARGS'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Forwards its args to git running with the correct key and in the notes root.'
      tput bold
      echo -n '  api_pushd'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  api_clone'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Clones the git reposity.'
      tput bold
      echo -n '  api_fsck'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Resets the mtime of notes files from git.'
      tput bold
      echo -n '  nw'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  window'
      echo
      tput sgr0
      tput setaf 6
      echo "    alias nwin='q notes window'"
      tput sgr0
      tput bold
      echo -n '  api_find'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Runs find automatically scoped to the right mtime by the NEND and NSTART env'
      echo '    variables.'
      tput bold
      echo -n '  api_quick_title'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  log'
      echo
      tput sgr0
      tput setaf 6
      echo "    alias nlog='q notes log'"
      tput sgr0
      tput bold
      echo -n '  api_match_files'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Returns a list of files, as absolute paths, that match a search query. The'
      echo '    query is a list of terms, separated by spaces. Each term is either a'
      echo '    pro-pattern, or an anti-pattern:'
      echo '    '
      echo '    Pro-pattern terms are regular words (e.g. '"'"'foo'"'"') that MUST appear in the file.'
      echo '    If there are multiple pro-pattern terms, then they all must appear for a file'
      echo '    to match (match all).'
      echo '    '
      echo '    Anti-pattern terms start with a tilde `~` (e.g. `~bar`). Any file containing'
      echo '    even one of the anti-pattern terms is excluded from the results.'
      echo '    '
      echo '    Without any pro-patterns, starts with matching all files.'
      echo '    '
      echo '    Additional flags start with a dash '"'"'-'"'"', to be supplied in any position:'
      echo '    '
      echo '    -w match only complete words (DEFAULT) -W match substrings'
      tput bold
      echo -n '  ls'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' TERM'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      echo "    alias nls='q notes ls'"
      tput sgr0
      echo '    Prints a tree of notes, with the TERM as a filter.'
      tput bold
      echo -n '  hist'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' N'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      echo "    alias nhist='q notes hist'"
      tput sgr0
      echo '    Prints the N most recent notes.'
      tput bold
      echo -n '  api_drop_note'
      echo -n ' NOTE'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Delete the note at the provided relative path.'
      tput bold
      echo -n '  gc'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Deletes empty notes and runs git gc.'
      tput bold
      echo -n '  api_update_note'
      tput setaf 9
      echo -n ' RELPATH'
      tput sgr0
      tput bold
      echo -n ' CONTENTS'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Updates the note at the given relative path with the given contents.'
      tput bold
      echo -n '  api_edit_note'
      tput setaf 9
      echo -n ' PATH'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' LINE'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Opens vim for the given relative note path, then updates the notes tree using'
      echo '    the result. Optional second argument is the line number to open vim at.'
      tput bold
      echo -n '  api_perl_preview'
      echo -n ' PROG'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' TERM'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Applies the provided perl program to matching notes to generate replacements.'
      echo '    Returns the potential replacements.'
      ;;
    omdb)
      echo "Usage: q omdb FUNCTION [ARG...]"
      echo "OMDB (Open Movie Database) helpers for bash."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  set_key'
      echo -n ' KEY'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Configure a new KEY for the OMDB API.'
      tput bold
      echo -n '  register_key'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Interactive prompt to configure the API key for OMDB.'
      tput bold
      echo -n '  get_key'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Prints the API key for OMDB.'
      tput bold
      echo -n '  query'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -f'
      tput sgr0
      tput bold
      echo -n ' QUERY'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Query the OMDB API with the given query. Prints JSON to stdout. Results are'
      echo '    cached. Use -f to force a fresh query.'
      echo '    '
      echo '    The query consists of a series of PARAMETER=QUERY pairs. Valid parameters are'
      echo '    documented at http://www.omdbapi.com.'
      echo '    '
      echo '    Examples:'
      echo '    q omdb query "t=The Matrix"'
      echo '    q omdb query "i=tt0133093"'
      echo '    '
      echo '    Useful parameters include:'
      echo '    '
      echo '    - t: Title of the movie.'
      echo '    - i: IMDB ID of the movie.'
      tput bold
      echo -n '  guess_title'
      tput setaf 9
      echo -n ' FILE'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Guess the title of the movie based on the filename.'
      ;;
    path)
      echo "Usage: q path FUNCTION [ARG...]"
      echo "UNIX style path helpers."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  expand'
      tput setaf 9
      echo -n ' PATH'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Expands tilde, safely, in the path.'
      tput bold
      echo -n '  push'
      tput setaf 1
      echo -n ' DIRECTORY'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    This is like pushd, except it also updates the name of the screen window to'
      echo '    the new path, if run from inside a screen session.'
      tput bold
      echo -n '  pop'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    This is like popd, except it also updates the name of the screen window to the'
      echo '    new path, if run from inside a screen session.'
      ;;
    pkg)
      echo "Usage: q pkg FUNCTION [ARG...]"
      echo "Cross-platform package management."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  install_or_skip'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' PACKAGE'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Install packages using the system package manager, or skip, if the package is'
      echo '    already installed.'
      ;;
    python)
      echo "Usage: q python FUNCTION [ARG...]"
      echo "Python env management, python-shell FFI and Jupyter."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  venv'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -I|--install-requirements'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -p|--python-path'
      tput sgr0
      tput bold
      tput setaf 9
      echo -n ' PATH'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -q|--quiet'
      tput sgr0
      tput bold
      echo -n ' VERSION'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      echo "    alias venv='q python venv'"
      tput sgr0
      echo '    Create a new virtualenv in the current directory, using the latest available'
      echo '    python version. If a virtualenv already exists, activate it. If -I is passed,'
      echo '    install requirements.txt. If -p is passed, use the specified Python binary. If'
      echo '    VERSION is passed, find a python binary with that version.'
      tput bold
      echo -n '  pip_run'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -p|--python-path'
      tput sgr0
      tput bold
      tput setaf 9
      echo -n ' PATH'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -P|--package'
      tput sgr0
      tput bold
      echo -n ' PACKAGE'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' EXE'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' ARGS'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Run a Python script with the specified package installed.'
      tput bold
      echo -n '  ipynb'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -I|--install-requirements'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -p|--python-path'
      tput sgr0
      tput bold
      tput setaf 9
      echo -n ' PATH'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' VERSION'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      echo "    alias ipynb='q python ipynb'"
      tput sgr0
      echo '    Creates a new virtualenv in the current directory (as venv) and opens a new'
      echo '    Jupyter notebook.'
      tput bold
      echo -n '  detect'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Find all available Python binaries in the PATH and their versions.'
      echo '    Prints a tab-separated list: VERSION  PATH  SHORT_VERSION'
      tput bold
      echo -n '  latest'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Returns the path to the latest available Python binary.'
      tput bold
      echo -n '  func'
      echo -n ' -f|--function'
      tput sgr0
      tput bold
      echo -n ' FUNCTION'
      tput sgr0
      tput bold
      echo -n ' -p|--path'
      tput sgr0
      tput bold
      tput setaf 9
      echo -n ' PATH'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -J|--json_output'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' --clean'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' --debug'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' --quiet'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' --no-venv'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' --'
      tput sgr0
      tput bold
      echo -n ' ARGS'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Run a Python function from a file. Calls `q python venv` to setup the'
      echo '    environment. The function must be defined in the file and must be a top-level'
      echo '    function. The function must be defined with type hints for all arguments.'
      echo '    '
      echo '    Function arguments are passed as positional arguments or keyword arguments.'
      echo '    Keyword arguments are passed as --KEY VALUE. Positional arguments are passed'
      echo '    after a single --.'
      echo '    '
      echo '    Example: python_func -f my_function -p my_file.py --kwarg val -- --arg1 arg2'
      echo '    '
      echo '    Arguments:'
      echo '    -f|--function: The name of the function to run.'
      echo '    -p|--path: The path to the Python file.'
      echo '    -J|--json-output: Serialize the output as JSON.'
      echo '    --clean: Delete the virtualenv after running the function.'
      echo '    --debug: Print the Python script that was executed.'
      echo '    --quiet: Do not print any output from the virtualenv creation.'
      echo '    --no-venv: Do not create a virtualenv.'
      tput bold
      echo -n '  black'
      echo -n ' ['
      tput sgr0
      tput bold
      tput setaf 9
      echo -n ' FILES'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Run the black code formatter on the specified files.'
      ;;
    quick)
      echo "Usage: q quick FUNCTION [ARG...]"
      echo "Redshell function help, switch and autocomplete."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  rebuild'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' --src-path'
      tput sgr0
      tput bold
      tput setaf 9
      echo -n ' PATH'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' --skip-extra-paths'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  q'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    rust)
      echo "Usage: q rust FUNCTION [ARG...]"
      echo "Manage rust toolchain and environment."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  rustup'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  install_goodies'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    screen)
      echo "Usage: q screen FUNCTION [ARG...]"
      echo "UNIX style path helpers."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  session'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  window'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  rename'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  home'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  reset_dirname'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    strings)
      echo "Usage: q strings FUNCTION [ARG...]"
      echo "String helpers for bash."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  urlencode'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Usage strings_urlencode STRING'
      echo '    '
      echo '    URL-encodes a string. DO NOT USE with curl: prefer --data-urlencode.'
      tput bold
      echo -n '  strip_control'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Strips terminal escape sequences from standard input.'
      tput bold
      echo -n '  repeat'
      echo -n ' STRING'
      tput sgr0
      tput bold
      echo -n ' N'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Prints STRING N times.'
      tput bold
      echo -n '  join'
      echo -n ' DELIMITER'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' STRING'
      tput sgr0
      tput bold
      echo -n ' ...'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  sgrep'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -C'
      tput sgr0
      tput bold
      echo -n ' NUM'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      echo "    alias sgrep='q strings sgrep'"
      tput sgr0
      tput bold
      echo -n '  strip_prefix'
      echo -n ' PREFIX'
      tput sgr0
      tput bold
      echo -n ' STRING'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Strips the prefix from the string if it'"'"'s there.'
      tput bold
      echo -n '  trim'
      echo -n ' STRING'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Strips leading and trailing whitespace from a string.'
      ;;
    time)
      echo "Usage: q time FUNCTION [ARG...]"
      echo "Time and date helpers."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  zones'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    List all time zones know to the system. (In /usr/share/zoneinfo.)'
      echo '    '
      echo '    This doesn'"'"'t include aliases declared in this package.'
      tput bold
      echo -n '  get_tz'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  local'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  utc'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  in'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Usage time_in TIMEZONE [FORMAT]'
      echo '    '
      echo '    Sets the time zone to TIMEZONE and runs date with the remaining arguments.'
      echo '    Timezone resolution suppors fuzzy matching and aliases, so that cities like'
      echo '    San Francisco work as timezones.'
      tput bold
      echo -n '  tz_diff'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  ts'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    transit)
      echo "Usage: q transit FUNCTION [ARG...]"
      echo "Transit helpers."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  sbb'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    util)
      echo "Usage: q util FUNCTION [ARG...]"
      echo "Catch-all utility functions that don't fit anywhere else."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  sud'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  reload'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  markdown'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  human_size'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -b|-bb|-S|-h|-hh'
      tput sgr0
      tput bold
      echo -n ' SIZE'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Convert SIZE to human-readable format.'
      echo '    '
      echo '    -b: bits'
      echo '    -bb: SI units'
      echo '    -S: SI bytes'
      echo '    -h: base-2 bytes'
      echo '    -hh: base-2 bytes, no space between number and unit'
      echo '    '
      echo '    If no mode switch is specified then normal, base-2 byte units are used.'
      tput bold
      echo -n '  install_heroku_cli'
      echo
      tput sgr0
      tput setaf 6
      echo "    alias heroku_install_cli='q util install_heroku_cli'"
      tput sgr0
      tput bold
      echo -n '  bazel'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  jup'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  wait_for_file'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  forex'
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -f'
      tput sgr0
      tput bold
      echo -n ' FROM'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -t'
      tput sgr0
      tput bold
      echo -n ' TO'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -d'
      tput sgr0
      tput bold
      echo -n ' DATE'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -a'
      tput sgr0
      tput bold
      echo -n ' AMOUNT'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo -n ' ['
      tput sgr0
      tput bold
      echo -n ' -v'
      tput sgr0
      tput bold
      echo -n ' ]'
      tput sgr0
      tput bold
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    xterm_colors)
      echo "Usage: q xterm_colors FUNCTION [ARG...]"
      echo "Work with the xterm color space, convert to RGB, etc."
      echo
      echo "Available functions:"
      tput bold
      echo -n '  channel_step'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Takes one RGB channel value as a 2-byte hex string and returns a decimal'
      echo '    number representing the step in XTERM_CHANNEL_STEPS that'"'"'s the closest.'
      tput bold
      echo -n '  greyscale_step'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    As channel_step, but for greyscale.'
      tput bold
      echo -n '  rgb_to_xterm'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Takes an RGB color as a 6-byte hex string and returns the closest xterm color.'
      tput bold
      echo -n '  hue_diff'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Computes the hue difference between two RGB colors passed as 6-byte hex'
      echo '    strings. Result is in the interval [0; 765]. Contrast values greater than ~400'
      echo '    are usually legible for text, if sufficient brightness contrast also exists.'
      echo '    (Depends on terminal.)'
      tput bold
      echo -n '  brightness'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Computes the brightness of an RGB color passed as a 6-byte hex string. Result'
      echo '    is in the interval [0; 255]. Brightness contrast of ~100 is usually legible if'
      echo '    sufficient hue contrast also exists. (Depends on terminal.)'
      tput bold
      echo -n '  contrast'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Computes a contrast value between two RGB colors passed as 6-byte hex strings.'
      echo '    Result is in the interval [0; 192]. Combines hue and brightness information.'
      echo '    Contrast values over 80 are usually legible, depending on terminal.'
      tput bold
      echo -n '  xterm_to_rgb'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      echo '    Takes an xterm color number as a decimal integer and returns a 6-byte hex of'
      echo '    the RGB color.'
      tput bold
      echo -n '  xterm_to_fg'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  xterm_to_bg'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  tfmt'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  color'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  shades'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      tput bold
      echo -n '  colors'
      echo
      tput sgr0
      tput setaf 6
      tput sgr0
      ;;
    *)
      echo "Unknown module $1"
      return 1
      ;;
    esac
  fi
}
function __q_dump() {
  if [[ ! "$#" -eq 2 ]]; then
    echo "Usage: q dump MODULE FUNCTION"
    return 1
  fi
  case "$1" in
  ascii_art)
    case "$2" in
    print_speech_bubble)
      type print_speech_bubble
      ;;
    erase_lines)
      type erase_lines
      ;;
    cursor_position)
      type cursor_position
      ;;
    cursor_row)
      type cursor_row
      ;;
    print_bmo)
      type print_bmo
      ;;
    print_pedro)
      type print_pedro
      ;;
    scroll_output_pedro)
      type scroll_output_pedro
      ;;
    select_visual)
      type select_visual
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  bash)
    case "$2" in
    get_bash_functions)
      type get_bash_functions
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  browser)
    case "$2" in
    gdocs_id)
      type gdocs_id
      ;;
    sheets_dl_link)
      type sheets_dl_link
      ;;
    chrome_path)
      type chrome_path
      ;;
    downloads_path)
      type downloads_path
      ;;
    dl)
      type browser_dl
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  crypt)
    case "$2" in
    encrypt_symmetric)
      type encrypt_symmetric
      ;;
    decrypt_symmetric)
      type decrypt_symmetric
      ;;
    gen_github_keypair)
      type gen_github_keypair
      ;;
    package)
      type package
      ;;
    payloadify)
      type payloadify
      ;;
    downloadify)
      type downloadify
      ;;
    hash)
      type crypt_hash
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  debian)
    case "$2" in
    setup)
      type debian_setup
      ;;
    install_or_skip)
      type debian_install_or_skip
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  fedora)
    case "$2" in
    setup)
      type fedora_setup
      ;;
    dnf_install_or_skip)
      type dnf_install_or_skip
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  file)
    case "$2" in
    mktemp)
      type file_mktemp
      ;;
    mtime)
      type file_mtime
      ;;
    age)
      type file_age
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  find)
    case "$2" in
    f)
      type f
      ;;
    __f_args)
      type __f_args
      ;;
    fcc)
      type fcc
      ;;
    fgo)
      type fgo
      ;;
    fjava)
      type fjava
      ;;
    faidl)
      type faidl
      ;;
    fd)
      type fd
      ;;
    replace)
      type find_replace
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  git)
    case "$2" in
    mkproject)
      type mkproject
      ;;
    ssh_init)
      type git_ssh_init
      ;;
    changed_lines)
      type git_changed_lines
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  go)
    case "$2" in
    pkg_do)
      type go_pkg_do
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  grepo)
    case "$2" in
    checkout)
      type grepo_checkout
      ;;
    lfs_pull)
      type grepo_lfs_pull
      ;;
    remove_branch)
      type grepo_remove_branch
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  hg)
    case "$2" in
    root)
      type hg_root
      ;;
    repo_name)
      type hg_repo_name
      ;;
    branch_name)
      type hg_branch_name
      ;;
    ps1_widget)
      type hg_ps1_widget
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  init)
    case "$2" in
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  install)
    case "$2" in
    file)
      type install_file
      ;;
    reinstall_file)
      type reinstall_file
      ;;
    __install_file)
      type __install_file
      ;;
    __uninstall_file)
      type __uninstall_file
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  keys)
    case "$2" in
    git)
      type keys_git
      ;;
    path)
      type keys_path
      ;;
    var)
      type keys_var
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  mac)
    case "$2" in
    setup)
      type mac_setup
      ;;
    brew)
      type brew
      ;;
    get_user_shell)
      type mac_get_user_shell
      ;;
    brew_bash_path)
      type mac_brew_bash_path
      ;;
    switch_to_bash)
      type mac_switch_to_bash
      ;;
    icloud)
      type icloud
      ;;
    icloud_evict)
      type icloud_evict
      ;;
    brew_install_or_skip)
      type brew_install_or_skip
      ;;
    install_miniconda)
      type mac_install_miniconda
      ;;
    install_devtools)
      type mac_install_devtools
      ;;
    kill_defender)
      type mac_kill_defender
      ;;
    suppress_defender)
      type mac_suppress_defender
      ;;
    kill_crashplan)
      type mac_kill_crashplan
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  media)
    case "$2" in
    yt-dl)
      type yt-dl
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  monitor)
    case "$2" in
    __load_stats_worker)
      type __load_stats_worker
      ;;
    __stream_tick)
      type __stream_tick
      ;;
    stream_load_stats)
      type stream_load_stats
      ;;
    __write_load_stats_worker)
      type __write_load_stats_worker
      ;;
    load_hist)
      type load_hist
      ;;
    latest_load_stats)
      type latest_load_stats
      ;;
    __parse_load_stats)
      type __parse_load_stats
      ;;
    write_load_stats)
      type write_load_stats
      ;;
    stream_top_stats)
      type stream_top_stats
      ;;
    __parse_top_header)
      type __parse_top_header
      ;;
    __parse_units)
      type __parse_units
      ;;
    __stream_net_stats_worker)
      type __stream_net_stats_worker
      ;;
    __parse_nettop)
      type __parse_nettop
      ;;
    stream_net_stats)
      type stream_net_stats
      ;;
    proc_stats)
      type proc_stats
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  mtg)
    case "$2" in
    __mtg_latest_scryfall_oracle_cards_uri)
      type __mtg_latest_scryfall_oracle_cards_uri
      ;;
    oracle_json)
      type mtg_oracle_json
      ;;
    rules)
      type mtg_rules
      ;;
    card_json)
      type mtg_card_json
      ;;
    __mtg_approx_match)
      type __mtg_approx_match
      ;;
    __colorize_mana)
      type __colorize_mana
      ;;
    __print_card)
      type __print_card
      ;;
    card)
      type mtg_card
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  multiple_choice)
    case "$2" in
    __prompt)
      type __prompt
      ;;
    __multiple_choice)
      type __multiple_choice
      ;;
    multiple_choice)
      type multiple_choice
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  net)
    case "$2" in
    online)
      type net_online
      ;;
    health)
      type net_health
      ;;
    ssh_fingerprint)
      type net_ssh_fingerprint
      ;;
    dump_cert)
      type net_dump_cert
      ;;
    ccurl)
      type net_ccurl
      ;;
    dataurl)
      type net_dataurl
      ;;
    undataurl)
      type net_undataurl
      ;;
    rtt)
      type net_rtt
      ;;
    ip4)
      type net_ip4
      ;;
    ip4gw)
      type net_ip4gw
      ;;
    serve)
      type net_serve
      ;;
    dump_url)
      type dump_url
      ;;
    wiki)
      type wiki
      ;;
    wifi_device)
      type wifi_device
      ;;
    wifi_name)
      type net_wifi_name
      ;;
    ssh_fingerprint)
      type net_ssh_fingerprint
      ;;
    ssh_aliases)
      type net_ssh_aliases
      ;;
    ssh_fqdn)
      type net_ssh_fqdn
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  news)
    case "$2" in
    all)
      type news_all
      ;;
    stocks)
      type news_stocks
      ;;
    weather)
      type news_weather
      ;;
    brutalist_report_source)
      type news_brutalist_report_source
      ;;
    nytimes)
      type news_nytimes
      ;;
    npr)
      type news_npr
      ;;
    pbs)
      type news_pbs
      ;;
    register)
      type news_register
      ;;
    cnbc)
      type news_cnbc
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  notes)
    case "$2" in
    __elide)
      type __elide
      ;;
    __file_mtime_and_age)
      type __file_mtime_and_age
      ;;
    __notes_api_list_notes_batch)
      type __notes_api_list_notes_batch
      ;;
    note)
      type notes_note
      ;;
    list)
      type notes_list
      ;;
    sync)
      type notes_sync
      ;;
    todo)
      type notes_todo
      ;;
    undo)
      type notes_undo
      ;;
    perl)
      type notes_perl
      ;;
    api_list_notes)
      type notes_api_list_notes
      ;;
    __nonempty_wc_l)
      type __nonempty_wc_l
      ;;
    backup)
      type notes_backup
      ;;
    api_empty_notes)
      type notes_api_empty_notes
      ;;
    __date_add)
      type __date_add
      ;;
    __wday)
      type __wday
      ;;
    __date_sub)
      type __date_sub
      ;;
    __date_convert)
      type __date_convert
      ;;
    __wday_number)
      type __wday_number
      ;;
    __relative_moment)
      type __relative_moment
      ;;
    __when)
      type __when
      ;;
    __notes_api_list_todos_batch)
      type __notes_api_list_todos_batch
      ;;
    api_list_todos)
      type notes_api_list_todos
      ;;
    print_todo_categories)
      type print_todo_categories
      ;;
    __todo_context_emoji)
      type __todo_context_emoji
      ;;
    __select_todo)
      type __select_todo
      ;;
    api_git)
      type notes_api_git
      ;;
    api_pushd)
      type notes_api_pushd
      ;;
    api_clone)
      type notes_api_clone
      ;;
    __fix_mtime_from_git)
      type __fix_mtime_from_git
      ;;
    api_fsck)
      type notes_api_fsck
      ;;
    __date_unit)
      type __date_unit
      ;;
    __parse_age)
      type __parse_age
      ;;
    nw)
      type nw
      ;;
    window)
      type notes_window
      ;;
    api_find)
      type notes_api_find
      ;;
    api_quick_title)
      type notes_api_quick_title
      ;;
    __notes_filename)
      type __notes_filename
      ;;
    log)
      type notes_log
      ;;
    __match_files_one)
      type __match_files_one
      ;;
    __match_files_all)
      type __match_files_all
      ;;
    __match_files_regex)
      type __match_files_regex
      ;;
    api_match_files)
      type notes_api_match_files
      ;;
    __todo_title)
      type __todo_title
      ;;
    __notes_title)
      type __notes_title
      ;;
    __notes_category)
      type __notes_category
      ;;
    __preamble)
      type __preamble
      ;;
    ls)
      type notes_ls
      ;;
    hist)
      type notes_hist
      ;;
    api_drop_note)
      type notes_api_drop_note
      ;;
    __notes_gen)
      type __notes_gen
      ;;
    gc)
      type notes_gc
      ;;
    api_update_note)
      type notes_api_update_note
      ;;
    api_edit_note)
      type notes_api_edit_note
      ;;
    __notes_api_perl_preview_batch)
      type __notes_api_perl_preview_batch
      ;;
    api_perl_preview)
      type notes_api_perl_preview
      ;;
    __nperl_render_preview)
      type __nperl_render_preview
      ;;
    __nperl_apply)
      type __nperl_apply
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  omdb)
    case "$2" in
    __omdb_key_path)
      type __omdb_key_path
      ;;
    set_key)
      type omdb_set_key
      ;;
    register_key)
      type omdb_register_key
      ;;
    get_key)
      type omdb_get_key
      ;;
    __omdb_query_string)
      type __omdb_query_string
      ;;
    query)
      type omdb_query
      ;;
    guess_title)
      type omdb_guess_title
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  path)
    case "$2" in
    expand)
      type path_expand
      ;;
    push)
      type path_push
      ;;
    pop)
      type path_pop
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  pkg)
    case "$2" in
    install_or_skip)
      type pkg_install_or_skip
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  python)
    case "$2" in
    __python_ensurepip)
      type __python_ensurepip
      ;;
    __python_ensurevenv)
      type __python_ensurevenv
      ;;
    __fix_stupid_virtualenv_behavior)
      type __fix_stupid_virtualenv_behavior
      ;;
    venv)
      type python_venv
      ;;
    pip_run)
      type python_pip_run
      ;;
    ipynb)
      type python_ipynb
      ;;
    detect)
      type python_detect
      ;;
    latest)
      type python_latest
      ;;
    func)
      type python_func
      ;;
    black)
      type python_black
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  quick)
    case "$2" in
    __quick_build_all)
      type __quick_build_all
      ;;
    rebuild)
      type quick_rebuild
      ;;
    q)
      type q
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  rust)
    case "$2" in
    rustup)
      type rustup
      ;;
    install_goodies)
      type rust_install_goodies
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  screen)
    case "$2" in
    session)
      type screen_session
      ;;
    window)
      type screen_window
      ;;
    rename)
      type screen_rename
      ;;
    home)
      type screen_home
      ;;
    reset_dirname)
      type screen_reset_dirname
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  strings)
    case "$2" in
    urlencode)
      type strings_urlencode
      ;;
    strip_control)
      type strings_strip_control
      ;;
    repeat)
      type strings_repeat
      ;;
    join)
      type strings_join
      ;;
    sgrep)
      type strings_sgrep
      ;;
    strip_prefix)
      type strings_strip_prefix
      ;;
    trim)
      type strings_trim
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  time)
    case "$2" in
    zones)
      type time_zones
      ;;
    __time_get_tz_alias)
      type __time_get_tz_alias
      ;;
    __time_get_tz)
      type __time_get_tz
      ;;
    get_tz)
      type time_get_tz
      ;;
    local)
      type time_local
      ;;
    utc)
      type time_utc
      ;;
    in)
      type time_in
      ;;
    tz_diff)
      type time_tz_diff
      ;;
    ts)
      type time_ts
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  transit)
    case "$2" in
    sbb)
      type transit_sbb
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  util)
    case "$2" in
    sud)
      type sud
      ;;
    reload)
      type reload
      ;;
    markdown)
      type util_markdown
      ;;
    human_size)
      type human_size
      ;;
    install_heroku_cli)
      type install_heroku_cli
      ;;
    bazel)
      type bazel
      ;;
    jup)
      type jup
      ;;
    wait_for_file)
      type wait_for_file
      ;;
    forex)
      type util_forex
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  xterm_colors)
    case "$2" in
    channel_step)
      type channel_step
      ;;
    greyscale_step)
      type greyscale_step
      ;;
    rgb_to_xterm)
      type rgb_to_xterm
      ;;
    hue_diff)
      type hue_diff
      ;;
    brightness)
      type brightness
      ;;
    contrast)
      type contrast
      ;;
    xterm_to_rgb)
      type xterm_to_rgb
      ;;
    xterm_to_fg)
      type xterm_to_fg
      ;;
    xterm_to_bg)
      type xterm_to_bg
      ;;
    tfmt)
      type tfmt
      ;;
    color)
      type color
      ;;
    shades)
      type shades
      ;;
    colors)
      type colors
      ;;
    *)
      echo "Unknown function $2"
      return 1
      ;;
    esac
    ;;
  *)
    echo "Unknown module $1"
    return 1
    ;;
  esac
}

function __q_compgen() {
  local modules="ascii_art bash browser crypt debian fedora file find git go grepo hg init install keys mac media monitor mtg multiple_choice net news notes omdb path pkg python quick rust screen strings time transit util xterm_colors"
  case "${COMP_CWORD}" in
  1)
    COMPREPLY=($(compgen -W "help ${modules}" -- ${COMP_WORDS[COMP_CWORD]}))
    return 0
  ;;
  2)
    case "${COMP_WORDS[1]}" in
    ascii_art)
      COMPREPLY=($(compgen -W "help print_speech_bubble erase_lines cursor_position cursor_row print_bmo print_pedro scroll_output_pedro select_visual" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    bash)
      COMPREPLY=($(compgen -W "help get_bash_functions" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    browser)
      COMPREPLY=($(compgen -W "help gdocs_id sheets_dl_link chrome_path downloads_path dl" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    crypt)
      COMPREPLY=($(compgen -W "help encrypt_symmetric decrypt_symmetric gen_github_keypair package payloadify downloadify hash" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    debian)
      COMPREPLY=($(compgen -W "help setup install_or_skip" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    fedora)
      COMPREPLY=($(compgen -W "help setup dnf_install_or_skip" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    file)
      COMPREPLY=($(compgen -W "help mktemp mtime age" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    find)
      COMPREPLY=($(compgen -W "help f fcc fgo fjava faidl fd replace" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    git)
      COMPREPLY=($(compgen -W "help mkproject ssh_init changed_lines" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    go)
      COMPREPLY=($(compgen -W "help pkg_do" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    grepo)
      COMPREPLY=($(compgen -W "help checkout lfs_pull remove_branch" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    hg)
      COMPREPLY=($(compgen -W "help root repo_name branch_name ps1_widget" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    init)
      COMPREPLY=($(compgen -W "help " -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    install)
      COMPREPLY=($(compgen -W "help file reinstall_file" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    keys)
      COMPREPLY=($(compgen -W "help git path var" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    mac)
      COMPREPLY=($(compgen -W "help setup brew get_user_shell brew_bash_path switch_to_bash icloud icloud_evict brew_install_or_skip install_miniconda install_devtools kill_defender suppress_defender kill_crashplan" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    media)
      COMPREPLY=($(compgen -W "help yt-dl" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    monitor)
      COMPREPLY=($(compgen -W "help stream_load_stats load_hist latest_load_stats write_load_stats stream_top_stats stream_net_stats proc_stats" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    mtg)
      COMPREPLY=($(compgen -W "help oracle_json rules card_json card" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    multiple_choice)
      COMPREPLY=($(compgen -W "help multiple_choice" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    net)
      COMPREPLY=($(compgen -W "help online health ssh_fingerprint dump_cert ccurl dataurl undataurl rtt ip4 ip4gw serve dump_url wiki wifi_device wifi_name ssh_fingerprint ssh_aliases ssh_fqdn" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    news)
      COMPREPLY=($(compgen -W "help all stocks weather brutalist_report_source nytimes npr pbs register cnbc" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    notes)
      COMPREPLY=($(compgen -W "help note list sync todo undo perl api_list_notes backup api_empty_notes api_list_todos print_todo_categories api_git api_pushd api_clone api_fsck nw window api_find api_quick_title log api_match_files ls hist api_drop_note gc api_update_note api_edit_note api_perl_preview" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    omdb)
      COMPREPLY=($(compgen -W "help set_key register_key get_key query guess_title" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    path)
      COMPREPLY=($(compgen -W "help expand push pop" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    pkg)
      COMPREPLY=($(compgen -W "help install_or_skip" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    python)
      COMPREPLY=($(compgen -W "help venv pip_run ipynb detect latest func black" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    quick)
      COMPREPLY=($(compgen -W "help rebuild q" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    rust)
      COMPREPLY=($(compgen -W "help rustup install_goodies" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    screen)
      COMPREPLY=($(compgen -W "help session window rename home reset_dirname" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    strings)
      COMPREPLY=($(compgen -W "help urlencode strip_control repeat join sgrep strip_prefix trim" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    time)
      COMPREPLY=($(compgen -W "help zones get_tz local utc in tz_diff ts" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    transit)
      COMPREPLY=($(compgen -W "help sbb" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    util)
      COMPREPLY=($(compgen -W "help sud reload markdown human_size install_heroku_cli bazel jup wait_for_file forex" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    xterm_colors)
      COMPREPLY=($(compgen -W "help channel_step greyscale_step rgb_to_xterm hue_diff brightness contrast xterm_to_rgb xterm_to_fg xterm_to_bg tfmt color shades colors" -- ${COMP_WORDS[COMP_CWORD]}))
      return 0
      ;;
    esac
    ;;
  *)
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"
    case "${COMP_WORDS[1]}" in
    ascii_art)
      case "${COMP_WORDS[2]}" in
      print_speech_bubble)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      erase_lines)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      cursor_position)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      cursor_row)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      print_bmo)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      print_pedro)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      scroll_output_pedro)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      select_visual)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    bash)
      case "${COMP_WORDS[2]}" in
      get_bash_functions)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    browser)
      case "${COMP_WORDS[2]}" in
      gdocs_id)
        # gdocs_id URL
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      sheets_dl_link)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      chrome_path)
        # chrome_path
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      downloads_path)
        # downloads_path
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      dl)
        # browser_dl URL
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    crypt)
      case "${COMP_WORDS[2]}" in
      encrypt_symmetric)
        # encrypt_symmetric FILE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(FILE)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      decrypt_symmetric)
        # decrypt_symmetric FILE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(FILE)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      gen_github_keypair)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      package)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      payloadify)
        # payloadify FILE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(FILE)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      downloadify)
        # downloadify FILE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(FILE)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      hash)
        # crypt_hash ALGO [INPUT]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    debian)
      case "${COMP_WORDS[2]}" in
      setup)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      install_or_skip)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    fedora)
      case "${COMP_WORDS[2]}" in
      setup)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      dnf_install_or_skip)
        # dnf_install_or_skip package1 package2 ...
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(1)
        local positional_types=(STRING STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    file)
      case "${COMP_WORDS[2]}" in
      mktemp)
        # file_mktemp [TITLE]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      mtime)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      age)
        # file_age [-s] PATH
        local switch_names=()
        local keyword_names=(-s)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -s)
              state="EXPECT_VALUE_FILE"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    find)
      case "${COMP_WORDS[2]}" in
      f)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      fcc)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      fgo)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      fjava)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      faidl)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      fd)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      replace)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    git)
      case "${COMP_WORDS[2]}" in
      mkproject)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ssh_init)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      changed_lines)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    go)
      case "${COMP_WORDS[2]}" in
      pkg_do)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    grepo)
      case "${COMP_WORDS[2]}" in
      checkout)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      lfs_pull)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      remove_branch)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    hg)
      case "${COMP_WORDS[2]}" in
      root)
        # hg_root
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      repo_name)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      branch_name)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ps1_widget)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    install)
      case "${COMP_WORDS[2]}" in
      file)
        # install_file -s|--sfile SFILE -d|--dfile DFILE [-c|--char CHAR] [-k|--section SECTION] [-d|--append] [--uninstall]
        local switch_names=(-d --append --uninstall)
        local keyword_names=(-s --sfile -d --dfile -c --char -k --section)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -s)
              state="EXPECT_VALUE_FILE"
              ;;
            -d)
              state="EXPECT_VALUE_FILE"
              ;;
            -c)
              state="EXPECT_VALUE_STRING"
              ;;
            -k)
              state="EXPECT_VALUE_STRING"
              ;;
            -d)
              state="EXPECT_ARG"
              ;;
            --uninstall)
              state="EXPECT_ARG"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      reinstall_file)
        # reinstall_file SFILE DFILE [CHAR] [SECTION]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(FILE FILE STRING STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    keys)
      case "${COMP_WORDS[2]}" in
      git)
        # keys_git [ARGS ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      path)
        # keys_path [-f] KEY
        local switch_names=()
        local keyword_names=(-f)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -f)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      var)
        # keys_var KEY
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    mac)
      case "${COMP_WORDS[2]}" in
      setup)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      brew)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      get_user_shell)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      brew_bash_path)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      switch_to_bash)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      icloud)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      icloud_evict)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      brew_install_or_skip)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      install_miniconda)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      install_devtools)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      kill_defender)
        # mac_kill_defender
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      suppress_defender)
        # mac_suppress_defender
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      kill_crashplan)
        # mac_kill_crashplan
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    media)
      case "${COMP_WORDS[2]}" in
      yt-dl)
        # yt-dl [OPTIONS ...] URL
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(STRING STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    monitor)
      case "${COMP_WORDS[2]}" in
      stream_load_stats)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      load_hist)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      latest_load_stats)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      write_load_stats)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      stream_top_stats)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      stream_net_stats)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      proc_stats)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    mtg)
      case "${COMP_WORDS[2]}" in
      oracle_json)
        # mtg_oracle_json
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      rules)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      card_json)
        # mtg_card_json NAME
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      card)
        # mtg_card NAME
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    multiple_choice)
      case "${COMP_WORDS[2]}" in
      multiple_choice)
        # multiple_choice [-n|-L] [-i INPUT] [-p PAGE] [-m MSG] [-a ALPHABET] [-I CONTROLS] [-A CONTROL_ALPHABET]
        local switch_names=(-n -L)
        local keyword_names=(-i -p -m -a -I -A)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -n)
              state="EXPECT_ARG"
              ;;
            -i)
              state="EXPECT_VALUE_STRING"
              ;;
            -p)
              state="EXPECT_VALUE_STRING"
              ;;
            -m)
              state="EXPECT_VALUE_STRING"
              ;;
            -a)
              state="EXPECT_VALUE_STRING"
              ;;
            -I)
              state="EXPECT_VALUE_STRING"
              ;;
            -A)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    net)
      case "${COMP_WORDS[2]}" in
      online)
        # net_online
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      health)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ssh_fingerprint)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      dump_cert)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ccurl)
        # net_ccurl [-M|--max-age SECONDS] [-K|--key KEY] -- CURL_ARGS...
        local switch_names=()
        local keyword_names=(-M --max-age -K --key --)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -M)
              state="EXPECT_VALUE_STRING"
              ;;
            -K)
              state="EXPECT_VALUE_STRING"
              ;;
            --)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      dataurl)
        # dataurl FILE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(FILE)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      undataurl)
        # undataurl
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      rtt)
        # rtt HOST
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(HOSTNAME)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ip4)
        # net_ip4
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ip4gw)
        # net_ip4gw
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      serve)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      dump_url)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      wiki)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      wifi_device)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      wifi_name)
        # net_wifi_name
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ssh_fingerprint)
        # net_ssh_fingerprint HOST
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(HOSTNAME)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ssh_aliases)
        # net_ssh_aliases
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ssh_fqdn)
        # net_ssh_fqdn ALIAS
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    news)
      case "${COMP_WORDS[2]}" in
      all)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      stocks)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      weather)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      brutalist_report_source)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      nytimes)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      npr)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      pbs)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      register)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      cnbc)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    notes)
      case "${COMP_WORDS[2]}" in
      note)
        # notes_note [NOTE]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      list)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      sync)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      todo)
        # notes_todo [TERM ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      undo)
        # notes_undo [-f]
        local switch_names=(-f)
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -f)
              state="EXPECT_ARG"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      perl)
        # notes_perl PROG [TERM ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(1)
        local positional_types=(STRING STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_list_notes)
        # notes_api_list_notes [-f] [-a] [TERM ...]
        local switch_names=(-f)
        local keyword_names=(-a)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -f)
              state="EXPECT_ARG"
              ;;
            -a)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      backup)
        # notes_backup
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_empty_notes)
        # notes_api_edit_notes
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_list_todos)
        # notes_api_list_todos [CONTEXT] [TERM ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(1)
        local positional_types=(STRING STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      print_todo_categories)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_git)
        # notes_api_git [ARGS ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_pushd)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_clone)
        # notes_api_clone
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_fsck)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      nw)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      window)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_find)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_quick_title)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      log)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_match_files)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ls)
        # notes_list [TERM ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      hist)
        # notes_hist [N]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_drop_note)
        # notes_api_drop_note NOTE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      gc)
        # notes_gc
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_update_note)
        # notes_api_update_note RELPATH CONTENTS
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(FILE STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_edit_note)
        # notes_api_edit_note PATH [LINE]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(FILE STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      api_perl_preview)
        # notes_api_perl_preview PROG [TERM ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(1)
        local positional_types=(STRING STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    omdb)
      case "${COMP_WORDS[2]}" in
      set_key)
        # omdb_set_key KEY
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      register_key)
        # omdb_register_key
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      get_key)
        # omdb_get_key
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      query)
        # omdb_query [-f] [QUERY ...]
        local switch_names=()
        local keyword_names=(-f)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -f)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      guess_title)
        # omdb_guess_title FILE
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(FILE)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    path)
      case "${COMP_WORDS[2]}" in
      expand)
        # path_expand PATH
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(FILE)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      push)
        # path_push DIRECTORY
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(DIRECTORY)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      pop)
        # path_pop
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    pkg)
      case "${COMP_WORDS[2]}" in
      install_or_skip)
        # pkg_install_or_skip [PACKAGE...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    python)
      case "${COMP_WORDS[2]}" in
      venv)
        # python_venv [-I|--install-requirements] [-p|--python-path PATH] [-q|--quiet] [VERSION]
        local switch_names=(-I --install-requirements)
        local keyword_names=(-p --python-path -q --quiet)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -I)
              state="EXPECT_ARG"
              ;;
            -p)
              state="EXPECT_VALUE_FILE"
              ;;
            -q)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      pip_run)
        # python_pip_run [-p|--python-path PATH] [-P|--package PACKAGE] [EXE] [ARGS...]
        local switch_names=()
        local keyword_names=(-p --python-path -P --package)
        local repeated_names=()
        local repeated_positions=(1)
        local positional_types=(STRING STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -p)
              state="EXPECT_VALUE_FILE"
              ;;
            -P)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ipynb)
        # python_ipynb [-I|--install-requirements] [-p|--python-path PATH] [VERSION]
        local switch_names=(-I --install-requirements)
        local keyword_names=(-p --python-path)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -I)
              state="EXPECT_ARG"
              ;;
            -p)
              state="EXPECT_VALUE_FILE"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      detect)
        # python_detect
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      latest)
        # python_latest
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      func)
        # python_func -f|--function FUNCTION -p|--path PATH [-J|--json_output] [--clean] [--debug] [--quiet] [--no-venv] [--] [ARGS...]
        local switch_names=(-J --json_output --clean --debug --quiet --no-venv)
        local keyword_names=(-f --function -p --path --)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -f)
              state="EXPECT_VALUE_STRING"
              ;;
            -p)
              state="EXPECT_VALUE_FILE"
              ;;
            -J)
              state="EXPECT_ARG"
              ;;
            --clean)
              state="EXPECT_ARG"
              ;;
            --debug)
              state="EXPECT_ARG"
              ;;
            --quiet)
              state="EXPECT_ARG"
              ;;
            --no-venv)
              state="EXPECT_ARG"
              ;;
            --)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      black)
        # python_black [FILES...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(0)
        local positional_types=(FILE)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    quick)
      case "${COMP_WORDS[2]}" in
      rebuild)
        # quick_rebuild [--src-path PATH] [--skip-extra-paths]
        local switch_names=(--skip-extra-paths)
        local keyword_names=(--src-path)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            --src-path)
              state="EXPECT_VALUE_FILE"
              ;;
            --skip-extra-paths)
              state="EXPECT_ARG"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      q)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    rust)
      case "${COMP_WORDS[2]}" in
      rustup)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      install_goodies)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    screen)
      case "${COMP_WORDS[2]}" in
      session)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      window)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      rename)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      home)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      reset_dirname)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    strings)
      case "${COMP_WORDS[2]}" in
      urlencode)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      strip_control)
        # strings_strip_control
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      repeat)
        # strings_repeat STRING N
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      join)
        # strings_join DELIMITER [STRING ...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=(1)
        local positional_types=(STRING STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      sgrep)
        # strings_sgrep [-C NUM]
        local switch_names=()
        local keyword_names=(-C)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -C)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      strip_prefix)
        # strings_strip_prefix PREFIX STRING
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      trim)
        # strings_trim STRING
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=(STRING)
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    time)
      case "${COMP_WORDS[2]}" in
      zones)
        # time_zones
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      get_tz)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      local)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      utc)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      in)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      tz_diff)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      ts)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    transit)
      case "${COMP_WORDS[2]}" in
      sbb)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    util)
      case "${COMP_WORDS[2]}" in
      sud)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      reload)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      markdown)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      human_size)
        # human_size [-b|-bb|-S|-h|-hh] SIZE
        local switch_names=()
        local keyword_names=(-b -bb -S -h -hh)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -b)
              state="EXPECT_VALUE_STRING"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      install_heroku_cli)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      bazel)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      jup)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      wait_for_file)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      forex)
        # util_forex [-f] FROM [-t] TO [-d DATE] [-a] [AMOUNT] [-v]
        local switch_names=(-v)
        local keyword_names=(-f -t -d -a)
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            -f)
              state="EXPECT_VALUE_STRING"
              ;;
            -t)
              state="EXPECT_VALUE_STRING"
              ;;
            -d)
              state="EXPECT_VALUE_STRING"
              ;;
            -a)
              state="EXPECT_VALUE_STRING"
              ;;
            -v)
              state="EXPECT_ARG"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    xterm_colors)
      case "${COMP_WORDS[2]}" in
      channel_step)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      greyscale_step)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      rgb_to_xterm)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      hue_diff)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      brightness)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      contrast)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      xterm_to_rgb)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      xterm_to_fg)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      xterm_to_bg)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      tfmt)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      color)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      shades)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      colors)
        # [ARG...]
        local switch_names=()
        local keyword_names=()
        local repeated_names=()
        local repeated_positions=()
        local positional_types=()
        local i=3
        local state="EXPECT_ARG"
        local pos=0
        while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
          case "${state}" in
          IDK)
            break
            ;;
          EXPECT_ARG)
            case "${COMP_WORDS[i]}" in
            --)
              state="IDK"
              ;;
            *)
              state="EXPECT_ARG"
              (( pos++ ))
              ;;
            esac
            ;;
          esac
          (( i++ ))
        done
        COMPREPLY=()
        if [[ "${state}" == "EXPECT_ARG" ]]; then
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          if [[ -n "${positional_types[$pos]}" ]]; then
            state="EXPECT_VALUE_${positional_types[$pos]}"
          else
            return 0
          fi
        fi
        case "${state}" in
        EXPECT_VALUE_FILE)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        EXPECT_VALUE_DIRECTORY)
          COMPREPLY+=($(compgen -A directory -- ${cur}))
          ;;
        EXPECT_VALUE_USER)
          COMPREPLY+=($(compgen -A user -- ${cur}))
          ;;
        EXPECT_VALUE_GROUP)
          COMPREPLY+=($(compgen -A group -- ${cur}))
          ;;
        EXPECT_VALUE_HOSTNAME)
          COMPREPLY+=($(compgen -A hostname -- ${cur}))
          ;;
        EXPECT_VALUE_STRING)
          ;;
        IDK)
          COMPREPLY+=($(compgen -W "${keyword_names[*]} ${switch_names[*]}" -- ${cur}))
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        *)
          COMPREPLY+=($(compgen -A file -- ${cur}))
          ;;
        esac
        return 0
        ;;
      esac
      ;;
    esac
    ;;
  esac
}

complete -F __q_compgen q

fi
